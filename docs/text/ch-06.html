<html xmlns="http://www.w3.org/1999/xhtml" class="translated-ltr">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Desconocido</title>

  <link href="../stylesheet.css" rel="stylesheet" type="text/css">
  <link href="../page_styles.css" rel="stylesheet" type="text/css">
  <link type="text/css" rel="stylesheet" charset="UTF-8" href="./part0010_files/translateelement.css">
  <link type="text/css" rel="stylesheet" charset="UTF-8" href="./part0010_files/translateelement(1).css">
</head>

<body id="9H5K0-e167752e5b154d43a225b5f350ab7738" class="calibre">
  <div class="container">
    <h1 id="nav_point_111" class="not-in-toc">Capítulo 6 Consejos</h1>

    <p class="zw">Es hora de discutir los consejos en detalle, porque los usaremos con frecuencia en el resto de este
      libro. Es posible que ya esté familiarizado con parte o toda la información básica que se analiza en este
      capítulo.
      A familiar embúnado no estulo. Esto, estudie detenidamente, ya que su comprensión de los indicadores se basará en
      esta base.</p>

    <h2 id="nav_point_112" class="calibre24">6.1 Memoria y dirección</h2>

    <p class="zw">Como mencioné anteriormente, podemos pensar en la memoria de la computadora como una hilera de casas
      en
      una calle larga .</p>

    <p class="zw">This analogía es Bastante Útil, Pero también Tiene Limitaciones. La Memoria de la Computadora Consta
      de
      Cientos de Millones de bits Cada Uno de los Cuales PUEDE Contener el valor 0 o 1. Dado Que El Rango de esvalores
      Que
      El Rango de esvalores Que PUEDE represent un bit puede demarasia limitado, un solo bit no es muy útil. Por lo
      general, muchos bits se combinan en un grupo como una unidad, por lo que se puede almacenar un rango mayor de
      valores . máquina en una una real.</p>

    <p class="tu"><img alt="" src="../images/00066.jpeg" class="calibre14"></p>

    <p class="zw">Cada una de estas posiciones se denomina byte y cada byte contiene el número de bits necesarios para
      almacenar un carácter . La imagen de arriba no muestra el contenido de estas ubicaciones, pero cada ubicación en
      la
      memoria siempre contiene algún valor. Cada byte se identifica mediante una dirección, como se muestra en el número
      sobre la figura en la memoria siempre contiene algún valor .</p>

    <p class="zw">Para almacenar valores más grandes, combinamos dos o más bytes juntos como una unidad de memoria más
      grande. Por ejemplo, muchas máquinas almacenan números enteros en unidades de palabras, y cada palabra
      generalmente
      consta de la memoria 4 bytes se muestra en la imagen a continuación es la misma que la imagen de arriba, pero esta
      vez se expresa en palabras de 4 bytes.</p>

    <p class="tu"><img alt="" src="../images/00067.jpeg" class="calibre14"></p>

    <p class="zw">Dado Que contienen Más bits, en el Rango de Enteros pecado signo Que se pueden acomodar En Cada
      palabra
      es de 0 a 4294967295 (2 <sup class="calibre15">32</sup> -1), y el Rango de Enteros con signo Que se pueden
      acomodar
      es de -2147483648 (-2 <sup class="calibre15">31</sup> ) a 2147483647 (2 <sup class="calibre15">31</sup> -1).</p>

    <p class="zw">TENGA EN CUENTA Que AUNQUE Una palabra Contiene. 4 bytes, todavía Tiene Una Sola Dirección. En Cuanto
      A
      Si SU Dirección ES La s posición del byte Más A La Izquierda O EL byte mas a La Derecha, Diferentes Máquinas
      Tienen
      Diferentes regulaciones. Otra Cosa Una tener en <strong class="calibre3">cuenta</strong> es la <strong
        class="calibre3">alineación de límites de</strong> problemas de hardware (alineación de límites). En máquinas
      que
      requieren alineación de límites, la posición inicial del almacenamiento de valores enteros solo puede ser ciertos
      bytes específicos, generalment de uno hardware y rara vez ver a los programadores de C. Solo nos interesan dos
      cosas:</p>

    <p class="zw">1. Cada ubicación en la memoria está identificada por una dirección única.</p>

    <p class="zw">2. Cada ubicación en la memoria contiene un valor.</p>

    <h4 class="sigil_not_in_toc1">Dirección y contenido</h4>

    <p class="zw">Aquí hay otro ejemplo, esta vez muestra el contenido de 5 palabras en la memoria.</p>

    <table border="1" width="90%" class="calibre16">
      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="zw">100</p>
          </td>

          <td class="calibre21">
            <p class="zw">104</p>
          </td>

          <td class="calibre21">
            <p class="zw">108</p>
          </td>

          <td class="calibre21">
            <p class="zw">112</p>
          </td>

          <td class="calibre21">
            <p class="zw">116</p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="zw">112</p>
          </td>

          <td class="calibre21">
            <p class="zw">-1</p>
          </td>

          <td class="calibre21">
            <p class="zw">1078523331</p>
          </td>

          <td class="calibre21">
            <p class="zw">100</p>
          </td>

          <td class="calibre21">
            <p class="zw">108</p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">Aquí se muestra cinco números enteros, cada uno en su propia palabra .</p>

    <p class="zw">Sin embargo, es demasiado torpe recordar todas estas direcciones, por lo que una de las
      características
      que brindan los lenguajes de alto nivel es acceder a las ubicaciones de la memoria por nombre en lugar de La
      dirección jo que la imagen imagen de arriba, pero esta vez use nombres en lugar de direcciones.</p>

    <table border="1" width="90%" class="calibre16">
      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="zw">a</p>
          </td>

          <td class="calibre21">
            <p class="zw">B</p>
          </td>

          <td class="calibre21">
            <p class="zw">C</p>
          </td>

          <td class="calibre21">
            <p class="zw">D</p>
          </td>

          <td class="calibre21">
            <p class="zw">mi</p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="zw">112</p>
          </td>

          <td class="calibre21">
            <p class="zw">-1</p>
          </td>

          <td class="calibre21">
            <p class="zw">1078523331</p>
          </td>

          <td class="calibre21">
            <p class="zw">100</p>
          </td>

          <td class="calibre21">
            <p class="zw">108</p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">SUPUESTO POR, Estós nombres llamamos hijo LO QUE variables. Es Muy Importante Recordar Que la
      Asociación
      Entre el Nombre y la Descripción de la ubicación de la memoria no la proporciona el hardware, Sino Que la
      IMPLEMENTA
      EL compilador. Todas Estas variables de fors Más brindan conveniente de Recordar la dirección: el <strong
        class="calibre3">hardware aún accede a la ubicación de la memoria a través de la dirección</strong> .</p>

    <h2 id="nav_point_113" class="calibre24">6.2 Valor y tipo</h2>

    <p class="zw">Ahora los Valores almacenados ubicaciones ES veamos Estas. Las Dos Primeras Posiciones SE almacenan
      Como
      Números Enteros. La Tercera posicion almacena Entero ONU Número Muy Grande, la ordenada en las Posiciones del
      Y-Cuarta Quinta también almacenan Enteros. Aquí Están Las Declaraciones de Estas la Variables:</p>

    <p class="calibre13"><img alt="" src="../images/00068.gif" class="calibre14"></p>

    <p class="zw">EN estas declaraciones, las variables AYB SE utilizan Hecho para almacenar Valores enteros. Sin
      Embargo,
      establece que EL Valor almacenado POR c es un Valor de Punto flotante. Sin Embargo, EL Valor de c EN La Figura
      anterior es un número Entero. Entonces, ¿ Cual deberia ser? ¿ Entero o punto flotante?</p>

    <p class="zw">La Respuesta Es Que La variable de Contiene Una Secuencia de bits de Cuyo contenido es 0 o 1. Se
      pueden
      Interpretar Como Números Enteros o de punto flotante, SEGÚN SE de Como utilicen. Sí se EE.UU. Una instrucción
      aritmética de Nuel interpreto sí, número entero, y si se usa una instrucción de punto flotante, es un número de
      punto flotante.</p>

    <p class="zw">Este Hecho Lleva una ANU conclusión adicional Los: no se <strong class="calibre3">PUEDE Juzgar El Tipo
        De un valor simplemente comprobando SUS bits de</strong> . . De Para determinar S. El Tipo de valor (y su
      valor),
      Dębe OBSERVAR SE de Como EE.UU. el valor en Elor Programa Considerente El Si 32 bits en forma binaria:</p>
    <pre class="code"><code class="calibre8">01100111011011000110111101100010</code></pre>

    <p class="zw">A CONTINUACION SE muestran algunos adj de los MUCHOS Resultados en Los que se pueden Interpretar Estós
      bits. Estós Valores sí obtienen DE UN Procesador BASADO en Motorola 68000. si cambia El Sistema Y EE.UU.
      Diferentes
      Formatos de Datos e interprete los bits instráucción di serentes, LA bits de Interprète .</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">escribe</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">valor</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">1 entero de 32 bits</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1735159650</p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">2 enteros de 16 bits</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">26476 y 28514</p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">4 caracteres</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">glob</p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">Punto flotante</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1.116533 × 10 <sup class="calibre23">24</sup></p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">Instrucciones de la máquina</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">mendigar + 110 años + 102</p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">Aquí, solo un valor SE Puede Interpretar Como 5 Tipos Diferentes. Obviamente, el tipo de Valor No Es
      Una
      Característica tanto inherentes del valor en si, Sino Que Depende de la forma en Que se utilice. Tanto Por lo,
      párrafo Obtener la respu, párrafo obtener la respu el uso correcto del valor es muy importante.</p>

    <p class="zw">Por SUPUESTO, el compilador nos ayudará a Evitar ESTOS Errores. Si Declaramos c Como una flotante
      variable Cuando El Programa ACCEDA A Ella, el compilador generará INSTRUCCIONES en estado de coma flotante. Si
      accedemos a la variable de de unaante Manera elpropiada Manera elpropiada compilador emitirá ONU Mensaje de error
      o
      advertencia. Parece muy obvio ahora que el valor indicado en la figura es engañoso porque muestra la
      representación
      entera de c. De hecho, el verdadero valor de coma flotante es 3,14.</p>

    <h2 id="nav_point_114" class="calibre24">6.3 Contenido de las variables de puntero</h2>

    <p class="zw">Regresemos al tema de los punteros Y veamos las Declaraciones de las variables de dy e. Todos se
      declaran Como punteros y se inicializan con las Direcciones de las variables Otras. La Inicialización del puntero
      se
      Realiza con el operador y, Que se utilizació de la dir operador y , que se utiliza de la gene rar memoria del
      operando (ver Capítulo 5).</p>

    <table border="1" width="90%" class="calibre16">
      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="zw">a</p>
          </td>

          <td class="calibre21">
            <p class="zw">B</p>
          </td>

          <td class="calibre21">
            <p class="zw">C</p>
          </td>

          <td class="calibre21">
            <p class="zw">D</p>
          </td>

          <td class="calibre21">
            <p class="zw">mi</p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="zw">112</p>
          </td>

          <td class="calibre21">
            <p class="zw">-1</p>
          </td>

          <td class="calibre21">
            <p class="zw">3,14</p>
          </td>

          <td class="calibre21">
            <p class="zw">100</p>
          </td>

          <td class="calibre21">
            <p class="zw">108</p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">El contenido de dye son direcciones en lugar de valores enteros o de punto flotante. De hecho, se
      puede
      ver fácilmente en la figura que el contenido de d es consistente con la dirección de almacenamiento de a, y el
      contenido de e es consistente con la dirección de almacenamiento de c. Esto es exactamente lo que esperamos al
      inicializar estos dos punteros. Es muy importante distinguir la dirección (112) de la variable d de su contenido
      (100) Al mismo tiempo, también debe darse cuenta de 100 se usa para identificar otras ubicaciones (la dirección de
      ...). En este punto, la metáfora casa / calle ya no es válida, porque el contenido de una casa nunca puede ser la
      dirección de otra casa.</p>

    <p class="zw">Antes de pasar al siguiente paso, veamos algunas expresiones que involucran estas variables .</p>

    <p class="calibre13"><img alt="" src="../images/00069.gif" class="calibre14"></p>

    <p class="zw">¿ ¿Cuáles son los valores de las siguientes expresiones?</p>
    <pre class="code"><code class="calibre8">a
b
c
d
e</code></pre>

    <p class="zw">Los tres primeros son muy fáciles: el valor de a es 112, el valor de b es -1 y el valor de c es 3,14.
      Las variables de puntero son realmente muy fáciles. El valor de d es 100 y el valor de e es 108. . de Si Cree Que
      los Valores de tinte hijo 112 y 3,14, respectivamente, ja ONU m cometido m muy error comun La Declaración de tinte
      Como no hay punteros Cambia La Forma En Que sí evalúan Estas Expresiones: El valor de Una es variables el valor
      almacenado en la ubicación de memoria asignada a la variable .El valor de una variable es el valor almacenado en
      la
      ubicación de memoria asignada a la variable, incluso las variables de puntero no son una excepción.</p>

    <h2 id="nav_point_115" class="calibre24">6.4 Operador de acceso indirecto</h2>

    <p class="zw">El Proceso de Acceder a la Dirección apuntada Por un puntero Se llama indirección o desreferenciar El
      puntero. El operador utilizado para Realizar el acceso indirecto es el operador unario *. A Continuación apuntada
      Por un puntero Se llama indirección o desreferenciar El puntero. .</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor correcto</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">escribe</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">a</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">112</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">En t</p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">B</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">-1</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">En t</p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">C</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">3,14</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">flotador</p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">D</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">100</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">En t *</p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">mi</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">108</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">flotar *</p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">*D</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">112</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">En t</p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">*mi</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">3,14</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">flotador</p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">El valor de d es 100. Cuando usamos el operador de acceso indirecto en d, significa acceder a la
      ubicación de memoria 100 y mirar el valor allí. Por lo tanto, el valor de la derecha de * d es 112, el contenido
      de
      la posición 100, y su valor de la izquierda es la propia posición 100.</p>

    <p class="zw">Tenga en cuenta el tipo de cada expresión en la lista anterior: d es un puntero a un número entero, y
      desreferenciarlo producirá un valor entero. De manera similar, el acceso indirecto a float * producirá un valor
      flotante.</p>

    <p class="zw">In Circunstancias normales, sin La ubicación de Almacenamiento Elegida por el compilador para la
      variable Cada CONOCEMOS, por Lo Que No Podemos predecir SU DIRECCION DE antemano. Of this Manera, Cuando Dibujamos
      El Gráfico de puntero verdadera párrafo variables Cada, nos expresar la Dirección. ENTONCES , la mayoría de los
      libros se reemplazan por flechas, como se muestra a continuación:</p>

    <p class="tu"><img alt="" src="../images/00070.jpeg" class="calibre14"></p>

    <p class="zw">Sin embargo, esta notación puede causar malentendidos, porque la flecha puede hacer pensar
      erróneamente
      que se realiza una operación de acceso indirecto, pero en realidad no necesariamente realiza esta operación .
      ¿Cuál
      inferirías el valor de la expresión d?</p>

    <p class="zw">Si su Respuesta ca 112, then this flecha lo Engaña. La Respuesta Correcta Es La Dirección de una, sin
      contenido do. Sin embargo, this flecha Parece Llamar Do Atención sobre a. No Es Fácil Evitar Que su pensamientoas
      se
      See flechadoas se See AFECT , y este es el problema: a menos que haya un operador de referencia indirecto, no se
      deje engañar por las flechas.</p>

    <p class="zw">La siguiente notación de flechas revisada intenta eliminar este problema.</p>

    <p class="tu"><img alt="" src="../images/00071.jpeg" class="calibre14"></p>

    <p class="zw">La Intención of this notación es Mostrar el valor del puntero, Pero No darte Una pista Fuerte visual,
      pensando Que esta flecha es El Camino Que DEBEMOS Seguir. De Hecho, Si No Se Accede indirectamente a la variable
      de
      de puntero, Sulo valor es por lo que de conjunto simples de bits. Al Realizar una Operación de acceso indirecto,
      this notación utilizació una flecha Sólida para Indicar el acceso a la memoria Que se producen real.</p>

    <p class="zw">Tenga en Cuenta Que La Flecha Comienza Dentro del cuadro Porque Representa el valor almacenado en la
      variable. Asímismo, La Flecha Apunta una ANU Descripción de la ubicación en Lugar del valor almacenado en esa
      Descripción de la ubicación. This notación sugiere verdadera Descripción de la ubicación. Sigue a la flecha Será
      ONU
      valor l . De hecho, este es el caso, y lo veremos en el futuro.</p>

    <p class="zw">AUNQUE this notación de Flechas es Útil, para usarla correctamente, Dębe Recordar Que El Valor De Una
      variable de de puntero Es Un Número. La Flecha Muestra el valor de Este numero, Pero la notación de la flecha no
      eles Cambia que Unchou de Mero En Si Mismo. el puntero no TIENE uNA propiedad de acceso indirecto Incorporada, por
      Lo Que, un Menos Que Haya ONU operador de acceso indirecto en la Expresión, no Puede acceder a este la ubicación a
      la Que Apunta Como lo Muestra la flecha.</p>

    <h2 id="nav_point_116" class="calibre24">6.5 Punteros no inicializados e ilegales</h2>

    <p class="zw">El siguiente fragmento de código ilustra un error muy común:</p>

    <p class="calibre13"><img alt="" src="../images/00072.gif" class="calibre14"></p>

    <p class="zw">Esta declaración crea una variable de puntero llamada a, y la declaración de asignación subsiguiente
      almacena 12 en la ubicación de memoria apuntada por a.</p>

    <p class="editing-tag">advertir:</p>

    <blockquote class="ti_shi">
      <p class="zw"><br class="calibre1"></p>

      <p class="calibre2">Pero, ¿ de dónde viene un punto? Declaramos esta variable pero nunca la inicializamos, por lo
        que no tenemos forma de predecir dónde se almacenará el valor de 12. Desde este punto de vista, no hay
        diferencia
        entre las variables de puntero rasuntero variables de puntero. la variable es estática, se inicializará a 0;
        pero
        si la variable es automática, no se inicializará en absoluto. En cualquier caso, declarar un puntero a un número
        entero no "creará" el espacio de memoria utilizado para almacenaro.el valoracenaro.el</p>

      <p class="calibre2">Entonces, ¿ Qué SUCEDE si El Programa Realiza this Operación de Asignación? Si Tiene suerte,
        el
        valor inicial de un Será Una Dirección ilegal, por lo Que la instrucción de Asignación saldra mal y terminará
        elesteación de UNIX error del programa de segmentación" o "Falla de memoria" . Solicita al programa que intente
        acceder a una ubicación de memoria que no esté asignada al programa. En una PC con Windows, el acceso indirecto
        a
        punteros no inicializados o ilegales es una de las causas principal la excepción de protección general.</p>

      <p class="calibre2">Para aquellas Máquinas que requieren que los números enteros SE almacenen EN límites
        específicos, Si La Dirección de almacenamiento de este tipo de datos EN La Memoria está EN EL límite incorrecto,
        SE generará un error Al acceder A ESTA Dirección. Este tipo de error SE denomina "error de bus" en los sistemas
        UNIX.</p>

      <p class="calibre2">Situación Una Mas tumba Es Que Este puntero PUEDE Contener ocasionalmente Una Dirección legal.
        Lo siguiente es sencilla: se Modifica el valor en esa posición, localidad Aunque No tenia la Intención de
        modificarlo di tipoquees de Porigo, Que Causo el error PUEDE sin Tener Ninguna Relación con el Código utilizado
        originalmente para Manipular ESE valor. por lo Tanto, los antes de Realizar la ONU acceso indirecto a los
        punteros, Dębe Tener Mucho Cuidado de asegurarse de ialque se Hayan en</p>
    </blockquote>

    <h2 id="nav_point_117" class="calibre24">6.6 puntero NULO</h2>

    <p class="zw">El Estándar definir NULL puntero de la ONU, Como variable de uña de puntero especial, Lo Que SIGNIFICA
      Que No Apunta a nada. Para Hacer Que Una variable de de puntero NULL mar, PUEDE asignarle cero ONU valor. Para
      activo probar Si Una variable de de puntero es NULL, PUEDE Compararla con un valor cero. El valor cero se eligió
      debido a una convención de código fuente. En lo que respeta a la máquina, el valor real del puntero NULL puede ser
      diferente de este. En este caso, elilador será resable de la traducción entre el valor cero y el valor interno.
    </p>

    <p class="zw">El Concepto de punteros NULL Es Muy Útil Porque le Brinda Una forma de Indicar Que Un puntero en
      particular, sin Apunta ACTUALMENTE a nada. EJEMPLO Por, Una función f Utilizada para ENCONTRAR UN valor
      particular,
      En Una Matriz PUEDE Devolver la ONU elemento puntero altra. Si la matriz no contiene el valor de la condición
      especificada, la función devuelve un puntero NULL. Esta técnica permite que el valor de retorno transmita dos
      piezas
      diferentes de información. Primero, ¿ encontraste el elemento? En segundo lugar, si se encuentra, ¿ qué elemento
      es?
    </p>

    <p class="editing-tag">insinuación:</p>

    <blockquote class="ti_shi">
      <p class="zw"><br class="calibre1"></p>

      <p class="calibre2">AUNQUE ESTA Técnica es Extremadamente Común En Los Programas C, Viola los Principios de La
        Ingeniería de Software. De Usar Un Solo Valor para expresar DOS significados Diferentes ES Algo Peligroso,
        Porque
        ES EL Futuro es facil NO Poder adivinar cual es su Verdadera Intención. En Programas Grandes, Este Problema es:
        Aún más serio, Porque no Puede Tener Una visión clara de Todo el diseño en su mente. Una Estrategia Más segura
        es
        Dejar Que la Función devuelva dos Valores Independientes: El Primero esado EE.UU. párrafo, el valor
        dedependientes: Indicar si la búsqueda es exitosa; el segundo es un puntero, cuando el valor de estado indica
        que
        la búsqueda es exitosa, apunta al elemento encontrado.</p>
    </blockquote>

    <p class="zw">Desreferenciar el puntero puede obtener el valor al que apunta. Pero, por definición, el puntero NULL
      no
      apunta a nada. Por lo tanto, es ilegal eliminar la referencia a un puntero NULL. Antes de eliminar la as
      referenciae
      NULL. De que no sea un puntero NULL.</p>

    <p class="editing-tag">advertir:</p>

    <blockquote class="ti_shi">
      <p class="zw"><br class="calibre1"></p>

      <p class="calibre2">¿ Qué SUCEDE si Realiza ONU acceso indirecto NULL ONU puntero? Sus Resultados Varian DE UN
        compilador A Otro. En ALGUNAS Máquinas, accederá a la Descripción de la ubicación de memoria cero. El compilador
        PUEDE asegurarse de Que La ubicación de memoria cero variables, permacene variable de una, permacene no la
        máquina
        no le impide acceder o modificar esta ubicación .</p>

      <p class="calibre2">En otras máquinas, el acceso indirecto al puntero NULL provocará un error y finalizará el
        programa. Declarar este error es mucho mejor que ocultarlo, porque los programadores pueden solucionarlo más
        fácilmente.</p>
    </blockquote>

    <p class="zw"><br class="calibre1"></p>

    <p class="editing-tag">insinuación:</p>

    <blockquote class="ti_shi">
      <p class="zw"><br class="calibre1"></p>

      <p class="calibre2">Si todas las variables de puntero (no solo las ubicadas en la memoria estática) se pueden
        inicializar automáticamente en NULL, sería una bendición, pero no es el caso. Independientemente de cómo
        reaccione
        su máento quinoa al comport, unactena una quino quino de untá inicializar explícitamente TODAS LAS las variables
        de puntero. Si ya conoce la Dirección en La que se inicializará El puntero, inicialícelo en esa Dirección;. de
        lo
        contrario, inicialícelo en NULL Un Programa busque diseñadorue El puntero aneligia la El puntero aneligia de El
        puntero aneligia de ñadorue de inicialización puede ahorrar mucho tiempo de depuración.</p>
    </blockquote>

    <h2 id="nav_point_118" class="calibre24">6.7 Punteros, acceso indirecto y valores l</h2>

    <p class="zw">¿Se pueden utilizar como valores l expresiones que incluyan punteros? Si es así, ¿Que son? Después de
      una referencia rápida a la tabla de prioridades en la Tabla 5.1, se puede encontrar que el operando requerido por
      el
      operador de acceso indirecto es un valor r, pero el resultado producido por este operador es un valor l.</p>

    <p class="zw">Volvamos al ejemplo anterior. Teniendo en cuenta estas declaraciones a continuación.</p>
    <pre class="code"><code class="calibre8">int　a;
int　*d = &amp;a;</code></pre>

    <p class="zw">Considere la siguiente expresión:</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor de la izquierda</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Ubicación designada</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">a</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">sí</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">a</p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">D</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">sí</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">D</p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">*D</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">sí</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">a</p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">Las variables de puntero se pueden utilizar como lvalores, no porque sean punteros, sino porque son
      variables. El acceso indirecto a la variable de puntero significa que debemos acceder a la ubicación apuntada por
      el
      puntero. El acceso indirecto especifica una ubicación de memoria específica para que podamos usar el resultado de
      la
      expresión de acceso indirecto como un valor l. En las siguientes dos declaraciones,</p>
    <pre class="code"><code class="calibre8">*d = 10 - *d;
d = 10 - *d;　　← ???</code></pre>

    <p class="zw">La primera declaración contiene dos operaciones de acceso indirecto. El acceso indirecto de la derecha
      se usa como un valor r, por lo que su valor es el valor almacenado en la ubicación apuntada por d (el valor de a).
      El acceso indirecto de la izquierda se usa como un valor l, por lo que la posición (a) apuntada por d toma el
      resultado del cálculo de la expresión en el lado derecho de la asignación como su nuevo valor.</p>

    <p class="zw">La segunda declaración es ilegal, porque significa almacenar una cantidad entera (10- * d) en una
      variable de puntero. Cuando el tipo de variable que usamos realmente no es coherente con el tipo de variable que
      debería usarse, el compilador se quejará para ayudarnos a juzgar esta situación. Estas advertencias y mensajes de
      error son nuestros amigos, y el compilador nos ayuda generando estos mensajes. Aunque tener que lidiar con esta
      información es algo que somos reacios a hacer, de hecho es una buena idea corregir estos errores (especialmente
      aquellos mensajes de advertencia que no abortarán el proceso de compilación). En términos de corregir el programa,
      es mucho más conveniente dejar que el compilador le diga qué salió mal que depurar el programa usted mismo en el
      futuro. El depurador no puede identificar estos problemas con tanta precisión como el compilador.</p>

    <p class="editing-tag">K&amp;R C:</p>

    <blockquote class="ti_shi">
      <p class="zw"><br class="calibre1"></p>

      <p class="calibre2">Al mezclar punteros y valores enteros, el antiguo compilador de C no se quejará. Sin embargo,
        ahora conocemos más a fondo este conocimiento. Convertir un valor entero en un puntero o convertir un puntero en
        un valor entero es extremadamente raro, y este tipo de conversión suele ser un error inconsciente.</p>
    </blockquote>

    <h2 id="nav_point_119" class="calibre24">6.8 Punteros, acceso indirecto y variables</h2>

    <p class="zw">Si cree que ha dominado los punteros, eche un vistazo a esta expresión y vea si comprende lo que
      significa.</p>
    <pre class="code"><code class="calibre8">*&amp;a = 25;</code></pre>

    <p class="zw">Si tu respuesta es que asigna el valor 25 a la variable a, ¡enhorabuena! tienes razón. Analicemos esta
      expresión. Primero, el operador &amp; genera la dirección de la variable a, que es una constante de puntero (tenga
      en cuenta que no necesita conocer su valor real para usar esta constante de puntero). A continuación, el operador
      *
      accede a la dirección representada por su operando. En esta expresión, el operando es la dirección de a, por lo
      que
      el valor 25 se almacena en a.</p>

    <p class="zw">¿Hay alguna diferencia entre esta declaración y simplemente usar a = 25 ;? Funcionalmente, son
      iguales.
      Sin embargo, implica más operaciones. A menos que el compilador (u optimizador) sepa lo que está haciendo y
      descarte
      operaciones adicionales, el código de destino que produce será más grande y más lento. Peor aún, estos operadores
      adicionales empeoran la legibilidad del código fuente. Por estas razones, nadie usará deliberadamente expresiones
      como * &amp; a.</p>

    <h2 id="nav_point_120" class="calibre24">6.9 Constantes de puntero</h2>

    <p class="zw">Analicemos otra expresión. Suponiendo que la variable a se almacena en la ubicación 100, ¿qué hace la
      siguiente declaración?</p>
    <pre class="code"><code class="calibre8">*100 = 25;</code></pre>

    <p class="zw">Parece que 25 está asignado a a, porque a es la variable almacenada en la posición 100. ¡Pero esto
      está
      mal! Esta declaración es realmente ilegal, porque el tipo del valor literal 100 es un tipo integral y las
      operaciones de acceso indirecto solo se pueden aplicar a expresiones de tipo puntero. Si realmente desea almacenar
      25 en la posición 100, debe usar yeso.</p>
    <pre class="code"><code class="calibre8">*(int *)100 = 25;</code></pre>

    <p class="zw">La coerción convierte el valor 100 de "tipo entero" a "puntero a tipo entero" para que el acceso
      indirecto sea legal. Si se almacena a en la posición 100, esta declaración almacena el valor 25 en a. <strong
        class="calibre3">Sin embargo, ¡la oportunidad que tienes de utilizar esta técnica es única</strong> ! ¿Por qué?
      Como mencioné anteriormente, normalmente no puede predecir dónde colocará el compilador una variable en particular
      en la memoria, por lo que no puede saber su dirección de antemano. Es fácil usar el operador &amp; para obtener la
      dirección de una variable, pero la expresión se evaluará cuando se ejecute el programa y es demasiado tarde para
      copiar su resultado como una constante literal al código fuente.</p>

    <p class="zw">El único punto útil de esta técnica es que ocasionalmente necesitas acceder a una ubicación específica
      en la memoria a través de una dirección, no se usa para acceder a una variable, sino para acceder al hardware en
      sí.
      Por ejemplo, el sistema operativo necesita comunicarse con controladores de dispositivos de entrada y salida,
      iniciar operaciones de E / S y obtener resultados de operaciones anteriores. En algunas máquinas, la comunicación
      con el controlador del dispositivo se logra leyendo y escribiendo valores en una dirección de memoria específica.
      Sin embargo, en lugar de decir que estas operaciones acceden a la memoria, es mejor decir que acceden a la
      interfaz
      del controlador del dispositivo. De esta forma, se debe acceder a estas ubicaciones a través de sus direcciones,
      las
      cuales se conocen de antemano en este momento.</p>

    <p class="zw">El Capítulo 3 mencionó que no existe una notación incorporada para escribir constantes de puntero.
      Cuando es extremadamente raro usarlos, generalmente se escriben en forma de literales enteros y se convierten al
      tipo apropiado por coerción <a id="ac61" href="#anchor61" class="calibre5"><sup class="calibre15">[1]</sup></a> .
    </p>

    <h2 id="nav_point_121" class="calibre24">6.10 Punteros de punteros</h2>

    <p class="zw">Aquí nos tomamos un momento para ver un ejemplo para comenzar este próximo tema. Considere estas
      declaraciones:</p>
    <pre class="code"><code class="calibre8">int　a = 12;
int　*b = &amp;a;</code></pre>

    <p class="zw">Se les asigna memoria como se muestra en la siguiente figura:</p>

    <p class="tu"><img alt="" src="../images/00073.jpeg" class="calibre14"></p>

    <p class="zw">Supongamos que tenemos una tercera variable, llamada c, y la inicializamos con la siguiente
      declaración:
    </p>
    <pre class="code"><code class="calibre8">c = &amp;b;</code></pre>

    <p class="zw">Su aparición en la memoria es aproximadamente la siguiente:</p>

    <p class="tu"><img alt="" src="../images/00074.jpeg" class="calibre14"></p>

    <p class="zw">La pregunta es: ¿cuál es el tipo de c? Obviamente es un puntero, pero ¿a qué apunta? La variable b es
      un
      "puntero a un número entero", por lo que cualquier tipo que apunte a b debe ser un puntero a un "puntero a un
      número
      entero", más generalmente hablando, un puntero a un puntero.</p>

    <p class="zw">Es legal ¡Sí! Las variables de puntero, como otras variables, ocupan una ubicación específica en la
      memoria, por lo que es legal usar el operador &amp; para obtener su dirección <a id="ac62" href="#anchor62"
        class="calibre5"><sup class="calibre15">[2]</sup></a> .</p>

    <p class="zw">Entonces, ¿cómo se declara esta variable? declaración</p>
    <pre class="code"><code class="calibre8">int　**c;</code></pre>

    <p class="zw">Indica que el tipo de expresión ** c es int. La tabla 6.1 enumera algunas expresiones para ayudarnos a
      aclarar este concepto. Suponga que estas expresiones hacen las siguientes declaraciones.</p>

    <p class="calibre13"><img alt="" src="../images/00075.gif" class="calibre14"></p>

    <p class="zw">La única cara nueva en la tabla es la última expresión, analicémosla. El operador * es asociativo de
      derecha a izquierda, por lo que esta expresión es equivalente a * (* c), y debemos evaluarla capa por capa de
      adentro hacia afuera. * c visita la ubicación señalada por c, sabemos que es la variable b. El segundo operador de
      acceso indirecto accede a la dirección apuntada por esta ubicación, que es la variable a. El puntero del puntero
      no
      es difícil de entender, solo hay que prestar atención a todas las flechas, si aparece un operador de acceso
      indirecto en la expresión, puedes seguir la flecha para visitar la posición a la que apunta.</p>

    <p class="biao_ti">Tabla 6.1 Doble acceso indirecto</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Expresión equivalente</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">a</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">12</code></p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">b</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">&amp;a</code></p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*b</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">a, 12</code></p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">c</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">&amp;b</code></p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*c</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">b, &amp;a</code></p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">**c</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*b, a, 12</code></p>
          </td>
        </tr>
      </tbody>
    </table>

    <h2 id="nav_point_122" class="calibre24">6.11 Expresiones de puntero</h2>

    <p class="zw">Ahora observemos varias expresiones de puntero y veamos cómo se evalúan cuando se usan como valores l
      y
      valores r, respectivamente. Algunas expresiones se usan comúnmente, pero otras no se usan comúnmente. El propósito
      de este ejercicio no es darle un "libro de cocina" de tales expresiones, sino perfeccionar sus habilidades para
      leerlas y escribirlas. Primero, veamos algunas declaraciones.</p>
    <pre class="code"><code class="calibre8">char　ch = 'a';
char　*cp = &amp;ch;</code></pre>

    <p class="zw">Ahora, tenemos dos variables, que se inicializan de la siguiente manera:</p>

    <p class="tu"><img alt="" src="../images/00076.jpeg" class="calibre14"></p>

    <p class="zw">La figura también muestra la ubicación de la memoria después de ch, porque algunas de las expresiones
      que estamos evaluando accederán a ella (aunque solo se accederá en caso de error). Como no conocemos su valor
      inicial, usamos un signo de interrogación.</p>

    <p class="zw">Primero, comencemos con uno simple, como la siguiente expresión:</p>
    <pre class="code"><code class="calibre8">ch</code></pre>

    <p class="zw">Cuando se usa como rvalue, el valor de la expresión es 'a', como se muestra en la siguiente figura:
    </p>

    <p class="tu"><img alt="" src="../images/00077.jpeg" class="calibre14"></p>

    <p class="zw">La elipse gruesa indica que el valor de la variable ch es el valor de la expresión. Sin embargo,
      cuando
      esta expresión se usa como un lvalue, es la dirección de esta memoria en lugar del valor contenido en la
      dirección,
      por lo que su representación gráfica es diferente:</p>

    <p class="tu"><img alt="" src="../images/00078.jpeg" class="calibre14"></p>

    <p class="zw">En este momento, la posición está marcada con un cuadro grueso, lo que indica que esta posición es el
      resultado de la expresión. Además, su valor no se muestra porque no es importante. De hecho, este valor será
      reemplazado por un nuevo valor. Las siguientes expresiones aparecerán en forma de tabla. A continuación de cada
      tabla se encuentra una descripción del proceso de evaluación de expresiones.</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor correcto</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor de la izquierda</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">&amp;ch</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00079.jpeg" class="calibre14"></p>
          </td>

          <td class="calibre21">
            <p class="calibre2">ilegal</p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">Como rvalue, el valor de esta expresión es la dirección de la variable ch. Tenga en cuenta que este
      valor es el mismo que el valor almacenado en la variable cp, pero esta expresión no menciona cp, por lo que este
      valor de resultado no se genera debido a él. De esta forma, la elipse de la figura no se dibuja alrededor de la
      flecha de cp. La segunda pregunta es, ¿por qué esta expresión no es un valor legal? La tabla de prioridad muestra
      que el resultado del operador &amp; es un valor r y no se puede usar como un valor l. ¿Pero por qué? La respuesta
      es
      simple: cuando se evalúa la expresión &amp; ch, ¿dónde se debe almacenar su resultado en la computadora? Estará
      ubicado en algún lugar, pero no puede saber dónde está. Esta expresión no identifica ninguna ubicación específica
      en
      la memoria de la máquina, por lo que no es un valor legal.</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor correcto</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor de la izquierda</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">cp</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00080.jpeg" class="calibre14"></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00081.jpeg" class="calibre14"></p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">Has visto esta expresión antes. Su valor correcto es el valor de cp como se muestra en la figura. Su
      lvalue es la ubicación de la memoria donde se encuentra cp. Dado que esta expresión no realiza operaciones de
      acceso
      indirecto, no es necesario realizar el acceso indirecto como se muestra en la flecha.</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor correcto</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor de la izquierda</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">&amp;cp</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00082.jpeg" class="calibre14"></p>
          </td>

          <td class="calibre21">
            <p class="calibre2">ilegal</p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">Este ejemplo es similar a &amp; ch, pero esta vez tomamos la dirección de la variable de puntero. El
      tipo de este resultado es un puntero a un puntero a un carácter. De manera similar, la ubicación de almacenamiento
      de este valor no está claramente definida, por lo que esta expresión no es un valor legal.</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor correcto</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor de la izquierda</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*cp</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00083.jpeg" class="calibre14"></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00084.jpeg" class="calibre14"></p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">Ahora hemos agregado una operación de acceso indirecto, por lo que sus resultados no deberían
      sorprendernos. Pero las siguientes expresiones son más interesantes.</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor correcto</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor de la izquierda</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*cp + 1</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00085.jpeg" class="calibre14"></p>
          </td>

          <td class="calibre21">
            <p class="calibre2">ilegal</p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">Este diagrama incluye más cosas, así que analicémoslo paso a paso. Aquí hay dos operadores. La
      prioridad
      de * es mayor que +, por lo que la operación de acceso indirecto se realiza primero (como lo muestra la flecha
      sólida de cp a ch en la figura), y podemos obtener su valor (como lo muestra la elipse punteada). Tomamos una
      copia
      de este valor y lo agregamos a 1. El resultado final de la expresión es un carácter <code
        class="calibre8">‘b‘</code>. La línea de puntos en la figura representa el movimiento de datos cuando se evalúa
      la
      expresión. La ubicación de almacenamiento del resultado final de esta expresión no está claramente definida, por
      lo
      que no es un valor legal. La tabla de prioridades confirma que el resultado de + no se puede utilizar como un
      valor
      l.</p>

    <p class="zw">En este ejemplo, agregamos un paréntesis a la expresión anterior. Este paréntesis hace que la
      expresión
      realice primero la operación de suma, que es sumar 1 a la dirección almacenada en cp. El valor del resultado en
      este
      momento es el puntero mostrado por la elipse discontinua en la figura. La siguiente operación de acceso indirecto
      sigue a la flecha para acceder a la ubicación de la memoria inmediatamente después del cap. De esta manera, el
      valor
      de la derecha de esta expresión es el valor de esta posición, y su valor de la izquierda es la posición en sí.</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor correcto</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor de la izquierda</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*(cp + 1)</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00086.jpeg" class="calibre14"></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00087.jpeg" class="calibre14"></p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">Aquí tenemos que aprender un punto muy importante. Tenga en cuenta que el resultado de la operación de
      adición de punteros es un rvalue, porque su ubicación de almacenamiento no está claramente definida. Si no hay una
      operación de acceso indirecto, esta expresión no será un valor legal. Sin embargo, el acceso indirecto sigue al
      puntero para acceder a una ubicación específica. De esta manera, * (cp + 1) se puede usar como un lvalue, aunque
      cp
      + 1 en sí mismo no es un lvalue. El operador de acceso indirecto es uno de los pocos operadores cuyo resultado es
      un
      valor l.</p>

    <p class="zw">Sin embargo, esta expresión accede a la ubicación de la memoria después del cap. ¿Cómo sabemos qué se
      almacenó originalmente en ese lugar? En términos generales, no lo sabemos, por lo que expresiones como esta son
      ilegales. Exploraré este tema con más profundidad más adelante en este capítulo.</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor correcto</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor de la izquierda</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">++cp</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00088.jpeg" class="calibre14"></p>
          </td>

          <td class="calibre21">
            <p class="calibre2">ilegal</p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">Los operadores ++ y - se utilizan con bastante frecuencia en variables de puntero, por lo que es muy
      importante comprenderlos en este contexto. En esta expresión, aumentamos el valor de la variable puntero cp. (Para
      aclarar la figura, omitimos la adición). El resultado de la expresión es una copia del puntero incrementado,
      porque
      el prefijo ++ primero incrementa el valor de su operando y luego devuelve este resultado. La ubicación de
      almacenamiento de esta copia no está claramente definida, por lo que no es un valor legal.</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor correcto</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor de la izquierda</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">cp++</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00089.jpeg" class="calibre14"></p>
          </td>

          <td class="calibre21">
            <p class="calibre2">ilegal</p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">El operador sufijo ++ también aumenta el valor de cp, pero devuelve una copia del valor de cp y luego
      aumenta el valor de cp. De esta forma, el valor de esta expresión es una copia del valor original de cp.</p>

    <p class="zw">Los valores de las dos expresiones anteriores no son valores legales. Pero si agregamos operadores de
      acceso indirecto a la expresión, pueden convertirse en valores legales, como se muestra en las siguientes dos
      expresiones.</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor correcto</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor de la izquierda</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*++cp</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00090.jpeg" class="calibre14"></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00091.jpeg" class="calibre14"></p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">Aquí, el operador de acceso indirecto actúa sobre la copia del puntero incrementado, por lo que su
      rvalue es el valor de la dirección de memoria detrás de ch, y su lvalue es la ubicación misma.</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor correcto</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor de la izquierda</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*cp++</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00092.jpeg" class="calibre14"></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00093.jpeg" class="calibre14"></p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">El resultado de usar el operador de sufijo ++ es diferente: su rvalue y lvalue son respectivamente el
      valor de la variable ch y la ubicación de memoria de ch, que es lo que cp apuntó originalmente. De manera similar,
      el operador postfix ++ usa el valor de su operando original en la expresión circundante. La combinación del
      operador
      de acceso indirecto y el operador posfijo ++ es a menudo engañosa. La tabla de prioridad muestra que el operador
      sufijo ++ tiene una prioridad más alta que el operador *, pero el resultado de la expresión parece que la
      operación
      de acceso indirecto se realiza primero. De hecho, hay 3 pasos involucrados aquí: (1) el operador ++ produce una
      copia de cp, (2) luego el operador ++ aumenta el valor de cp, (3) finalmente, realiza una operación de acceso
      indirecto en la copia de cp.</p>

    <p class="zw">Esta expresión a menudo aparece en un bucle, primero inicialice el puntero con la dirección de una
      matriz y luego use esta expresión para acceder secuencialmente al contenido de la matriz. Algunos ejemplos de esto
      se muestran más adelante en este capítulo.</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor correcto</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor de la izquierda</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">++*cp</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00094.jpeg" class="calibre14"></p>
          </td>

          <td class="calibre21">
            <p class="calibre2">ilegal</p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">En esta expresión, dado que la asociatividad de estos dos operadores es de derecha a izquierda, la
      operación de acceso indirecto se realiza primero. Luego, el valor de la posición apuntada por cp se incrementa en
      1,
      y el resultado de la expresión es una copia de este valor después del incremento.</p>

    <p class="zw">En comparación con las expresiones anteriores, las últimas tres expresiones se utilizan menos en la
      práctica. Sin embargo, comprenderlos a fondo puede ayudarlo a mejorar sus habilidades.</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor correcto</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor de la izquierda</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">(*cp)++</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00095.jpeg" class="calibre14"></p>
          </td>

          <td class="calibre21">
            <p class="calibre2">ilegal</p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">Para usar el operador sufijo ++, debemos agregar paréntesis para que realice primero operaciones de
      acceso indirecto. El proceso de cálculo de esta expresión es similar a la expresión anterior, pero su valor de
      resultado es el valor original antes del incremento de ch.</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor correcto</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor de la izquierda</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">++*++cp</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00096.jpeg" class="calibre14"></p>
          </td>

          <td class="calibre21">
            <p class="calibre2">ilegal</p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">Esta expresión parece bastante extraña, pero de hecho no es complicada. Hay 3 operadores en esta
      expresión, por lo que parece un poco aterrador. Sin embargo, si los analiza uno por uno, encontrará que todos le
      son
      familiares. De hecho, hemos calculado previamente * ++ cp, por lo que ahora todo lo que tenemos que hacer es
      aumentar su valor de resultado. Pero comencemos desde el principio. Recuerde que la asociatividad de estos
      operadores es de derecha a izquierda, por lo que ++ cp se ejecuta primero. La elipse punteada debajo de cp
      representa el primer resultado intermedio. A continuación, accedemos indirectamente a este valor de copia, lo que
      nos permite acceder a la ubicación de la memoria detrás de ch. El segundo resultado intermedio está representado
      por
      un cuadro punteado, porque el siguiente operador lo usa como un lvalor. Finalmente, realizamos la operación ++ en
      esta posición, que consiste en incrementar su valor. La razón por la que mostramos el valor del resultado como? +1
      es porque no conocemos el valor original de esta posición.</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor correcto</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor de la izquierda</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">++*cp++</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><img alt="" src="../images/00097.jpeg" class="calibre14"></p>
          </td>

          <td class="calibre21">
            <p class="calibre2">ilegal</p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw">La diferencia entre esta expresión y la expresión anterior es que esta vez el primer operador ++ está
      en
      forma de sufijo en lugar de en forma de prefijo. Debido a su mayor prioridad, se ejecuta primero. La operación de
      acceso indirecto accede a la ubicación apuntada por cp en lugar de la ubicación detrás de la ubicación apuntada
      por
      cp.</p>

    <h2 id="nav_point_123" class="calibre24">6.12 Ejemplos</h2>

    <p class="zw">A continuación, se muestran algunos programas de ejemplo para ilustrar algunos usos comunes de las
      expresiones de puntero. El procedimiento 6.1 calcula la longitud de una cadena. No debería tener que escribir esta
      función usted mismo, porque ya hay una en la biblioteca, pero es un ejemplo útil.</p>
    <pre class="code"><code class="calibre8">/*
** 计算一个字符串的长度。
*/

#include &lt;stdlib.h&gt;

size_t
strlen( char *string )
{
　　　　 int　　 length = 0;

　　　　 /*
　　　　 ** 依次访问字符串的内容，计数字符数，直到遇见NUL终止符。
　　　　 */
　　　　 while( *string++ != '\0' )
　　　　　　　 　length += 1;

　　　　 return length;
}</code></pre>

    <p class="calibre2"><strong class="calibre3">Procedimiento 6.1 Longitud de la cadena</strong>　　　　　　　</p>

    <p class="calibre11">strlen.c</p>

    <p class="calibre13">Antes de que el puntero alcance el byte NUL al final de la cadena, el valor de la expresión *
      string ++ en la instrucción while siempre es verdadero. También aumenta el valor del puntero para la siguiente
      prueba. Esta expresión incluso puede manejar cadenas vacías correctamente.</p>

    <p class="editing-tag">advertir:</p>

    <blockquote class="ti_shi">
      <p class="zw"><br class="calibre1"></p>

      <p class="calibre2">Si se llama a esta función cuando se le pasa un puntero NULL, el acceso indirecto en la
        instrucción while fallará. ¿Debería la función comprobar esta condición antes de eliminar la referencia al
        puntero? Desde la perspectiva de la seguridad absoluta, este debería ser el caso. Sin embargo, esta función no
        es
        responsable de crear cadenas. Si encuentra que el parámetro es NULL, debe haber encontrado un error que apareció
        en otra parte del programa. Es lógico verificar si el puntero es válido cuando se crea, porque solo necesita ser
        verificado una vez. Esta función utiliza este método. Si la función falla porque el llamador descuidado es
        demasiado vago para verificar la validez de los parámetros, entonces se lo merece.</p>
    </blockquote>

    <p class="zw">Los procedimientos 6.2 y 6.3 agregaron una capa de acceso indirecto. Buscan un valor de carácter
      específico en algunas cadenas, pero usamos una matriz de punteros para representar estas cadenas, como se muestra
      en
      la Figura 6.1. Los parámetros de la función son cadenas y valor, cadenas es un puntero a una matriz de punteros y
      valor es el valor de carácter que estamos buscando. Tenga en cuenta que la matriz de punteros termina con un
      puntero
      NULL. La función comprobará</p>

    <p class="tu"><img alt="" src="../images/00098.jpeg" class="calibre14"></p>

    <p class="tu_ti">Figura 6.1 Matriz de punteros a cadenas</p>

    <p class="calibre2">Este valor se usa para determinar cuándo termina el ciclo. La siguiente línea de expresión</p>
    <pre class="code"><code class="calibre8">while( ( string = *strings++ ) != NULL ) {</code></pre>

    <p class="calibre2">Complete tres tareas: ⑴ Copia el puntero al que apuntan actualmente las cadenas a la cadena
      variable. ⑵ Aumenta el valor de las cadenas para que apunten al siguiente valor. ⑶ Prueba si la cadena es NULL.
      Cuando la cadena apunta al byte NUL como la marca de terminación en la cadena actual, el ciclo interno while
      finaliza.</p>
    <pre class="code"><code class="calibre8">/*
** 给定一个指向以NULL结尾的指针列表的指针，在列表中的字符串中查找一个特定的字符。
*/

#include &lt;stdio.h&gt;

#define　TRUE　　1
#define　FALSE　0

int
find_char( char **strings, char value )
{
　　　　　　char*string;　　　/* 我们当前正在查找的字符串 */

　　　　　　/*
　　　　　　** 对于列表中的每个字符串 ...
　　　　　　*/
　　　　　　while( ( string = *strings++ ) != NULL ){
　　　　　　　　　/*
　　　　　　　　　** 观察字符串中的每个字符，看看它是不是我们需要查找的那个。
　　　　　　　　　*/
　　　　　　　　　while( *string != '\0' ){
　　　　　　　　　　　 if( *string++ == value )
　　　　　　　　　　　　　　　　return TRUE;
　　　　　　　　　}
　　　　　　}
　　　　　　return FALSE;
}</code></pre>

    <p class="calibre2"><strong class="calibre3">Procedimiento 6.2 Buscar en un conjunto de cadenas: versión 1</strong>　
      　　　　　　　　</p>

    <p class="calibre11">s_srch1.c</p>

    <p class="zw">Si la cadena no ha llegado al final del byte NUL, ejecute la siguiente instrucción</p>
    <pre class="code"><code class="calibre8">if( *string++ == value )</code></pre>

    <p class="zw">Comprueba si el carácter actual coincide con el carácter que se va a encontrar y luego aumenta el
      valor
      del puntero para que apunte al siguiente carácter.</p>

    <p class="zw">El programa 6.3 logra la misma función, pero no necesita hacer una copia del puntero a cada cadena.
      Sin
      embargo, debido a los efectos secundarios, este programa destruirá esta matriz de punteros. Este efecto secundario
      hace que esta función sea menos útil que la versión anterior, porque solo es adecuada para el caso en que la
      cadena
      solo necesita buscarse una vez.</p>
    <pre class="code"><code class="calibre8">/*
** 给定一个指向以NULL结尾的指针列表的指针，在列表中的字符串中查找一个特定的字符。这个函数将破坏这些指针，所以它只适用于这组字符串只使用一次的情况。　
*/

#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

#define　TRUE　　 1
#define　FALSE　 0

int
find_char( char **strings, int value )
{
　　　　 assert( strings != NULL );

　　　　 /*
　　　　 ** 对于列表中的每个字符串 ...
　　　　 */
　　　　while( *strings != NULL ){
　　　　　　　　 /*
　　　　　　　　 ** 观察字符串中的每个字符，看看它是否是我们查找的那个。
　　　　　　　　 */
　　　　　　　　 while( **strings != '\0' ){
　　　　　　　　　　　 if( *(*strings)++ == value )
　　　　　　　　　　　　　　　return TRUE;
　　　　　　　　 }
　　　　　　　　 strings++;
　　　　}
　　　　　 return FALSE;
}</code></pre>

    <p class="calibre2"><strong class="calibre3">Procedimiento 6.3 Buscar en un conjunto de cadenas: versión 2</strong>　
      　　　　　　　　</p>

    <p class="calibre11">s_srch2.c</p>

    <p class="zw">Sin embargo, hay dos expresiones interesantes en el Programa 6.3. El primero es ** cadenas. La primera
      operación de acceso indirecto accede al puntero actual en la matriz de punteros, y la segunda operación de acceso
      indirecto accede al carácter actual en la cadena junto con el puntero. La instrucción while interna prueba el
      valor
      de este carácter y observa si se ha alcanzado el final de la cadena.</p>

    <p class="zw">La segunda expresión interesante es * (* cadenas) ++. Los paréntesis son necesarios para que las
      expresiones se evalúen en el orden correcto. La primera operación de acceso indirecto accede al puntero actual en
      la
      lista. La operación de incremento agrega 1 al valor en la posición apuntada por el puntero, pero la segunda
      operación de acceso indirecto actúa sobre la copia original del valor. El efecto directo de esta expresión es
      probar
      el carácter actual en la cadena actual para ver si se ha alcanzado el final de la cadena. Como efecto secundario,
      el
      valor del puntero al carácter de la cadena actual aumentará en 1.</p>

    <h2 id="nav_point_124" class="calibre24">6.13 Aritmética de punteros</h2>

    <p class="zw">Los programas 6.1 a 6.3 contienen algunas expresiones que implican la suma de valores de puntero y
      valores enteros. ¿Es legal realizar operaciones en punteros? La respuesta es que puede realizar determinadas
      operaciones, pero no todas las operaciones son legales. Además de las operaciones de adición, también puede
      realizar
      algunas otras operaciones en punteros, pero no muchas.</p>

    <p class="zw">El resultado de agregar un puntero a un número entero es otro puntero. La pregunta es, ¿hacia dónde
      apunta? Si agrega 1 a un puntero de carácter, el puntero generado por la operación apuntará al siguiente carácter
      en
      la memoria. Un flotante ocupa más de 1 byte de espacio de memoria. Si agrega 1 a un puntero a un flotante, ¿qué
      sucederá? ¿Apunta a un byte dentro del valor flotante?</p>

    <p class="zw">Afortunadamente, la respuesta es no. Cuando se realiza una operación aritmética en un puntero y un
      número entero, el número entero siempre se ajustará de acuerdo con el tamaño apropiado antes de realizar la
      operación de suma. Este "tamaño apropiado" es el tamaño del tipo al que apunta el puntero, y el "ajuste" es
      multiplicar el valor entero por el "tamaño apropiado". Para ilustrar mejor, imagine que en una determinada
      máquina,
      float ocupa 4 bytes. Al calcular la expresión del puntero de tipo flotante más 3, el 3 se ajustará (multiplicará)
      de
      acuerdo con el tamaño del tipo flotante (4 en este ejemplo). De esta manera, el valor entero realmente agregado al
      puntero es 12.</p>

    <p class="zw">Agregar 3 al puntero aumenta el valor del puntero en 3 flotadores en lugar de 3 bytes. Este
      comportamiento es más razonable que obtener un puntero a una ubicación dentro de un valor flotante. La tabla 6.2
      contiene algunos ejemplos de operaciones de suma. La belleza del ajuste es que el algoritmo de puntero no depende
      del tipo de puntero. En otras palabras, si p es un puntero a char, entonces la expresión p + 1 apunta al siguiente
      char. Si p es un puntero a un flotante, entonces p + 1 apunta al siguiente flotante, y lo mismo es cierto para
      otros
      tipos.</p>

    <p class="tu"><strong class="calibre3">Tabla 6.2 Resultados de la operación del puntero</strong></p>

    <table border="1" width="90%" class="calibre16">
      <tbody class="calibre20">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Suponga que p es un puntero a</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Y el tamaño de \ * p es ...</p>
          </th>

          <th class="calibre19">
            <p class="zw">Valor agregado al puntero</p>
          </th>
        </tr>

        <tr class="calibre22">
          <td rowspan="2" class="calibre21">
            <p class="calibre2">p + 1</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">carbonizarse</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1</p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">pequeño</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">2</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">2</p>
          </td>
        </tr>

        <tr class="calibre22">
          <td rowspan="2" class="calibre21">
            <p class="calibre2">p + 1</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">En t</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">4</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">4</p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">doble</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">8</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">8</p>
          </td>
        </tr>

        <tr class="calibre22">
          <td rowspan="4" class="calibre21">
            <p class="calibre2">p + 2</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">carbonizarse</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">2</p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">pequeño</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">2</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">4</p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">En t</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">4</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">8</p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">doble</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">8</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">dieciséis</p>
          </td>
        </tr>
      </tbody>
    </table>

    <h3 id="nav_point_125" class="calibre7">6.13.1 Operaciones aritméticas</h3>

    <p class="zw">Las operaciones aritméticas de puntero C están limitadas a dos formas. La primera forma es:</p>

    <p class="zw">Puntero ± entero</p>

    <p class="zw">El estándar define que este formulario solo se puede usar para un puntero a un elemento en una matriz,
      como se muestra en la figura siguiente.</p>

    <p class="tu"><img alt="" src="../images/00099.gif" class="calibre14"></p>

    <p class="zw">Y el tipo de resultado de este tipo de expresión también es un puntero. Esta forma también se aplica a
      la memoria obtenida por asignación dinámica usando la función malloc (ver Capítulo 11), aunque no se ha mencionado
      en el estándar para mencionar este hecho.</p>

    <p class="zw">Los elementos de la matriz se almacenan en ubicaciones de memoria contiguas y la dirección del
      siguiente
      elemento es mayor que la dirección del elemento anterior. Por lo tanto, podemos ver fácilmente que agregar 1 a un
      puntero hace que apunte al siguiente elemento de la matriz, agregar 5 hace que se muevan 5 elementos hacia la
      derecha, y así sucesivamente. Restar 3 de un puntero lo mueve 3 elementos hacia la izquierda. La extensión de
      enteros garantiza que las operaciones de suma en punteros puedan producir este resultado, independientemente de la
      longitud de los elementos de la matriz.</p>

    <p class="zw">Después de realizar la suma o resta en el puntero, si la posición apuntada por el puntero de resultado
      está antes del primer elemento de la matriz o después del último elemento de la matriz, el efecto no está
      definido.
      Es legal tener un puntero que apunte a la posición después del último elemento de la matriz, pero el acceso
      indirecto a este puntero puede fallar.</p>

    <p class="zw">Es hora de dar un ejemplo. Aquí hay un ciclo que inicializa todos los elementos de la matriz a cero.
      (El
      Capítulo 8 discutirá la comparación de eficiencia entre bucles similares y bucles que usan acceso de subíndice).
    </p>

    <p class="calibre13"><img alt="" src="../images/00100.gif" class="calibre14"></p>

    <p class="zw">La parte inicial de la instrucción for apunta vp al primer elemento de la matriz.</p>

    <p class="tu"><img alt="" src="../images/00101.jpeg" class="calibre14"></p>

    <p class="zw">La aritmética del puntero en este ejemplo se realiza con el operador ++. El valor de incremento 1 se
      multiplica por la longitud del flotador y el resultado se suma al puntero vp. Después del primer ciclo, la
      ubicación
      del puntero en la memoria es la siguiente:</p>

    <p class="tu"><img alt="" src="../images/00102.jpeg" class="calibre14"></p>

    <p class="zw">Después de 5 ciclos, vp apunta a la ubicación de la memoria después del último elemento de la matriz.
    </p>

    <p class="tu"><img alt="" src="../images/00103.jpeg" class="calibre14"></p>

    <p class="zw">El ciclo termina en este momento. Dado que el valor del subíndice comienza desde cero, el valor del
      subíndice del último elemento de una matriz con 5 elementos es 4. Por lo tanto, &amp; values ​​[N_VALUES]
      representa
      la dirección de la ubicación de la memoria después del último elemento de la matriz. Cuando vp alcanza este valor,
      sabemos que hemos llegado al final de la matriz, por lo que el ciclo termina.</p>

    <p class="zw">El puntero en este ejemplo finalmente apunta a la ubicación de la memoria después del último elemento
      de
      la matriz. El puntero puede obtener este valor legalmente, pero al realizar un acceso indirecto a él, puede
      acceder
      accidentalmente a la variable almacenada originalmente en esta ubicación. El programador generalmente no puede
      saber
      qué variable se almacenó originalmente en esa ubicación. Por lo tanto, en este caso, generalmente no se permite
      realizar operaciones de acceso indirecto en el puntero a esta ubicación.</p>

    <p class="zw">El segundo tipo de aritmética de punteros tiene la siguiente forma:</p>

    <p class="zw">Puntero-puntero</p>

    <p class="zw">Solo cuando ambos punteros apuntan a elementos de la misma matriz, se permite restar un puntero del
      otro
      puntero, como se muestra a continuación:</p>

    <p class="tu"><img alt="" src="../images/00104.jpeg" class="calibre14"></p>

    <p class="zw">El tipo del resultado de restar dos punteros es ptrdiff_t, que es un tipo entero con signo. El valor
      de
      la operación de resta es la distancia entre los dos punteros en la memoria (en unidades de la longitud del
      elemento
      de la matriz, no en bytes), porque el resultado de la operación de resta se dividirá por la longitud del tipo de
      elemento de la matriz. Por ejemplo, si p1 apunta a la matriz [i] y p2 apunta a la matriz [j], entonces el valor de
      p2-p1 es el valor de ji.</p>

    <p class="zw">Echemos un vistazo a cómo funciona en un tipo determinado. Suponga que el tipo de elementos de la
      matriz
      en la figura anterior es flotante y que cada elemento ocupa 4 bytes de espacio de memoria. Si la posición inicial
      de
      la matriz es 1000, el valor de p1 es 1004 y el valor de p2 es 1024, pero el valor de resultado de la expresión
      p2-p1
      será 5, porque la diferencia entre los dos punteros (20) será dividirse por cada elemento La longitud (4).</p>

    <p class="zw">De manera similar, este ajuste de la diferencia hace que el resultado de la operación del puntero sea
      independiente del tipo de datos. Independientemente del tipo de elementos contenidos en la matriz, el valor de
      esta
      resta de puntero es siempre 5.</p>

    <p class="zw">Entonces, ¿es legal la expresión p1-p2? Sí, si ambos punteros apuntan a elementos de la misma matriz,
      esta expresión es legal. En el ejemplo anterior, este valor será -5.</p>

    <p class="zw">Si los dos punteros no son elementos de la misma matriz, el resultado de la resta entre ellos no está
      definido. Al igual que si restas los números de casa de dos casas ubicadas en calles diferentes, es imposible
      obtener el número de casas entre las dos casas. El programador no tiene forma de conocer la posición relativa de
      las
      dos matrices en la memoria, si no lo sabe, la distancia entre los dos punteros no tiene sentido.</p>

    <p class="editing-tag">advertir:</p>

    <blockquote class="ti_shi">
      <p class="zw"><br class="calibre1"></p>

      <p class="calibre2">De hecho, la mayoría de los compiladores no comprobarán si el resultado de una expresión de
        puntero se encuentra dentro de un límite legal. Por lo tanto, el programador debe asumir la responsabilidad de
        garantizar esto. De manera similar, el compilador no le impedirá tomar la dirección de una variable escalar y
        realizar aritmética de puntero en ella, incluso si no puede predecir a qué variable apuntará el puntero generado
        por el resultado de la operación. Los punteros fuera de límites y los punteros a valores desconocidos son dos
        fuentes comunes de error. Cuando utilice aritmética de punteros, debe tener mucho cuidado y asegurarse de que el
        resultado de la operación apunte a algo significativo.</p>
    </blockquote>

    <h3 id="nav_point_126" class="calibre7">6.13.2 Operaciones relacionales</h3>

    <p class="zw">También existen restricciones para realizar operaciones relacionales en punteros. Es posible comparar
      dos valores de puntero con los siguientes operadores relacionales:</p>
    <pre class="code"><code class="calibre8">&lt;　　&lt;=　　&gt;　　&gt;=</code></pre>

    <p class="zw">Pero la premisa es que todos apuntan a elementos de la misma matriz. Dependiendo del operador que use,
      la expresión de comparación le dirá qué puntero apunta al elemento anterior o posterior de la matriz. El estándar
      no
      define qué resultado se producirá si se comparan dos punteros arbitrarios.</p>

    <p class="zw">Sin embargo, puede realizar una prueba de igualdad o desigualdad entre dos punteros arbitrarios,
      porque
      el resultado de este tipo de comparación no tiene nada que ver con el lugar donde el compilador elige almacenar
      los
      datos: los punteros apuntan a la misma dirección o apuntan a direcciones diferentes. .</p>

    <p class="zw">Observemos otro ciclo, que se usa para borrar todos los elementos de una matriz.</p>

    <p class="calibre13"><img alt="" src="../images/00105.gif" class="calibre14"></p>

    <p class="zw">La instrucción for usa una prueba relacional para determinar si se termina el ciclo. Esta prueba es
      legal, porque vp y las constantes de puntero apuntan a elementos en la misma matriz (de hecho, esta constante de
      puntero apunta a la ubicación de memoria después del último elemento de la matriz, aunque en la última
      comparación,
      vp también apunta a Esta ubicación, pero como no hemos realizado acceso indirecto a vp en este momento, es
      seguro).
      También es factible usar el operador! = En lugar del operador &lt;, porque si vp no alcanza su último valor, el
      resultado de esta expresión siempre es falso.</p>

    <p class="zw">Ahora considere el siguiente ciclo:</p>
    <pre class="code"><code class="calibre8">for( vp = &amp;values[N_VALUES]; vp &gt; &amp;values[0]; )
　　　*--vp = 0;</code></pre>

    <p class="zw">Es la misma tarea realizada por el ciclo anterior, pero los elementos de la matriz se borrarán en
      orden
      inverso. Dejamos que vp apunte a la ubicación de la memoria detrás del último elemento de la matriz, pero
      realizamos
      una operación de disminución antes del acceso indirecto a ella. Cuando vp apunta al primer elemento de la matriz,
      el
      ciclo termina, pero esto sucede después de que se borra el primer elemento de la matriz.</p>

    <p class="zw">Algunas personas pueden oponerse a expresiones como * - vp y encontrarlas menos legibles. Pero si lo
      "simplifica", vea lo que sucede en este ciclo:</p>
    <pre class="code"><code class="calibre8">　　 for( vp = &amp;values[N_VALUES – 1]; vp &gt;= &amp;values[0]; vp-- )
　　　　　 *vp = 0;</code></pre>

    <p class="zw">Ahora vp apunta al último elemento de la matriz y su operación de decremento se realiza en la parte de
      ajuste de la instrucción for. Hay un problema con este bucle, ¿puedes detectarlo?</p>

    <p class="editing-tag">advertir:</p>

    <blockquote class="ti_shi">
      <p class="zw"><br class="calibre1"></p>

      <p class="calibre2">Una vez que se borra el primer elemento de la matriz, el valor de vp también se restará de 1 y
        la siguiente operación de comparación se utilizará para finalizar el ciclo. Pero este es el problema: el valor
        de
        la expresión de comparación vp&gt; = &amp; values ​​[0] no está definido porque vp se ha movido fuera del límite
        de la matriz. El estándar permite comparar un puntero a un elemento de la matriz con un puntero a la ubicación
        de
        la memoria después del último elemento de la matriz, pero no permite la comparación con un puntero a la
        ubicación
        de la memoria antes del primer elemento de la matriz.</p>
    </blockquote>

    <p class="zw">De hecho, en la mayoría de los compiladores de C, este ciclo completará la tarea sin problemas. Sin
      embargo, aún debe evitar usarlo, porque el estándar no garantiza que funcione. Tarde o temprano, puede encontrar
      una
      máquina que falle este ciclo. Para los programadores responsables del código portátil, este tipo de problema es
      simplemente una pesadilla.</p>

    <h2 id="nav_point_127" class="calibre24">6.14 Resumen</h2>

    <p class="zw">Cada ubicación en la memoria de la computadora se identifica mediante una dirección. Por lo general,
      las
      ubicaciones de memoria adyacentes se agrupan, lo que permite almacenar un rango más amplio de valores. Un puntero
      es
      una variable cuyo valor representa una dirección de memoria.</p>

    <p class="zw">Ni el programador ni la computadora pueden determinar el tipo de un valor por su patrón de bits. El
      tipo
      está implícitamente determinado por la forma en que se usa el valor. El compilador puede asegurar que la relación
      entre la declaración del valor y el uso del valor sea apropiada, ayudándonos así a determinar el tipo de valor.
    </p>

    <p class="zw">El valor de una variable de puntero no es el valor almacenado en la ubicación de memoria a la que
      apunta. Debemos usar el acceso indirecto para obtener el valor almacenado en la ubicación a la que apunta. El
      resultado de una operación de acceso indirecto aplicada a un "puntero a un número entero" será un valor entero.
    </p>

    <p class="zw">Declarar una variable de puntero no asigna memoria automáticamente. Antes de realizar un acceso
      indirecto al puntero, el puntero debe inicializarse: apuntar a la memoria existente o asignarle memoria dinámica.
      Es
      ilegal realizar operaciones de acceso indirecto en variables de puntero no inicializadas y estos errores suelen
      ser
      difíciles de detectar. El resultado es a menudo un valor no relacionado que se modifica. Este tipo de error es
      difícil de detectar mediante la depuración.</p>

    <p class="zw">Un puntero NULL es un puntero que no apunta a nada. Se puede asignar a un puntero para indicar que el
      puntero no apunta a ningún valor. Las consecuencias de realizar operaciones de acceso indirecto en punteros NULL
      varían de un compilador a otro Dos consecuencias comunes son devolver el valor de la ubicación de memoria a cero y
      terminar el programa.</p>

    <p class="zw">Como cualquier otra variable, las variables de puntero también se pueden usar como lvalores. El valor
      producido por el acceso indirecto al puntero también es un valor l, porque esta expresión identifica una ubicación
      de memoria específica.</p>

    <p class="zw">A excepción de los punteros NULL, no hay una notación incorporada para representar las constantes de
      puntero, porque los programadores generalmente no pueden predecir dónde colocará el compilador las variables en la
      memoria. En casos raros, ocasionalmente necesitamos usar una constante de puntero, luego podemos crearla lanzando
      un
      valor entero a un tipo de puntero.</p>

    <p class="zw">Se pueden realizar algunas operaciones aritméticas limitadas con valores de puntero. Puede agregar un
      valor entero a un puntero o restar un valor entero de un puntero. En ambos casos, el valor entero se ajustará y el
      valor original se multiplicará por la longitud del tipo de objetivo del puntero. De esta manera, agregar 1 a un
      puntero hará que apunte a la siguiente variable, en cuanto a cuántos bytes ocupa la variable en la memoria, no
      tiene
      nada que ver con esto.</p>

    <p class="zw">Sin embargo, el resultado de la aritmética de punteros solo se puede predecir cuando actúa sobre la
      matriz. Es ilegal realizar operaciones aritméticas en cualquier puntero que no apunte a un elemento de matriz
      (pero
      a menudo es difícil de detectar). Si después de restar un puntero de un número entero, la posición a la que apunta
      el puntero generado por la operación está antes del primer elemento de la matriz, entonces también es ilegal. La
      operación de adición es ligeramente diferente. Si el puntero de resultado apunta a la ubicación de la memoria
      detrás
      del último elemento de la matriz, todavía es legal (pero no puede realizar operaciones de acceso indirecto en este
      puntero), pero no será legal después.</p>

    <p class="zw">Si ambos punteros apuntan a elementos de la misma matriz, se pueden restar. El resultado de la resta
      del
      puntero se ajusta (dividido por la longitud del tipo de elemento de la matriz) para indicar cuántos elementos
      están
      separados por los dos punteros en la matriz. Si dos punteros no apuntan a elementos de la misma matriz, entonces
      es
      un error restar entre ellos.</p>

    <p class="zw">Cualquier indicador puede compararse y probarse para determinar la igualdad o la desigualdad. Si ambos
      punteros apuntan a elementos de la misma matriz, también pueden realizar operaciones relacionales como &lt;,
      &lt;=,&gt; y&gt; = para determinar sus posiciones relativas en la matriz. Realice operaciones relacionales en dos
      punteros no relacionados y el resultado es indefinido.</p>

    <h2 id="nav_point_128" class="calibre24">6.15 Resumen de advertencias</h2>

    <p class="zw">1. Desreferenciar una variable puntero no inicializada por error.</p>

    <p class="zw">2. Desreferencia un puntero NULL por error.</p>

    <p class="zw">3. Se pasó incorrectamente un puntero NULL a la función.</p>

    <p class="zw">4. No se detectaron errores en la expresión del puntero, lo que dio lugar a resultados impredecibles.
    </p>

    <p class="zw">5. Reste un puntero para que apunte ilegalmente a la ubicación de la memoria antes del primer elemento
      de la matriz.</p>

    <h2 id="nav_point_129" class="calibre24">6.16 Resumen de consejos de programación</h2>

    <p class="zw">1. Un valor debe tener un solo significado.</p>

    <p class="zw">2. Si el puntero no apunta a nada significativo, establézcalo en NULL.</p>

    <h2 id="nav_point_130" class="calibre24">6.17 Problema</h2>

    <p class="zw hand">1. Si el tipo de un valor no se puede juzgar
      simplemente observando su patrón de bits, ¿cómo sabe la máquina cómo manipular el valor?</p>

    <p class="zw">2. ¿Por qué C no tiene una forma de declarar constantes de puntero literal?</p>

    <p class="zw">3. Suponga que el valor de un número entero es 244. ¿Por qué la máquina no interpreta este valor como
      una dirección de memoria?</p>

    <p class="zw hand">4. En algunas máquinas, el compilador
      almacena
      el valor 0 en la ubicación de memoria cero. Desreferenciar el puntero NULL accederá a esta ubicación. ¿Cuáles son
      las consecuencias de este método?</p>

    <p class="zw">5. ¿Existe alguna diferencia entre el proceso de evaluación de las expresiones (a) y (b)? Si es así,
      ¿cuál es la diferencia? Suponga que el valor de la compensación variable es 3.</p>

    <p class="calibre13"><img alt="" src="../images/00106.gif" class="calibre14"></p>

    <p class="zw hand">6. ¿Hay algún problema con el siguiente
      fragmento de código? Si es así, ¿cuál es el problema?</p>
    <pre class="code"><code class="calibre8">　int　 array[ARRAY_SIZE];
　int　 *pi;

　for(pi=&amp;array[0];pi&lt;&amp;array[ARRAY_SIZE];)
　　　　　*++pi=0;</code></pre>

    <p class="zw">7. La siguiente tabla muestra el contenido de varias ubicaciones de memoria. Cada ubicación se
      identifica por su dirección y el nombre de la variable almacenada en esa ubicación. Todos los números se expresan
      en
      forma decimal.</p>

    <p class="zw">Usando estos valores, calcule el valor de cada una de las siguientes expresiones usando 4 métodos.
      Primero, suponga que todas las variables son de tipo entero, encuentre el valor r de la expresión y luego
      encuentre
      su valor l, dando la dirección de la ubicación de memoria que especifica. A continuación, asumiendo que todas las
      variables apuntan a números enteros, repita los pasos anteriores. Nota: Al realizar cálculos de dirección, se
      asume
      que la longitud del entero y el puntero es de 4 bytes.</p>

    <table border="1" width="90%" class="calibre16">
      <thead class="calibre17">
        <tr class="calibre18">
          <th class="calibre19">
            <p class="calibre2">variable</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Dirección</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">contenido</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">variable</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Dirección</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">contenido</p>
          </th>
        </tr>
      </thead>

      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">a</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1040</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1028</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">o</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1096</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1024</p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">C</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1056</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1076</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">q</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1084</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1072</p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">D</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1008</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1016</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">r</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1068</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1048</p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">mi</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1032</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1088</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">s</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1004</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">2000</p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">F</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1052</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1044</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">t</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1060</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1012</p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">gramo</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1000</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1064</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">tu</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1036</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1092</p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">h</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1080</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1020</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">v</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1092</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1036</p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">I</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1020</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1080</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">w</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1012</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1060</p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">j</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1064</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1000</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">X</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1072</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1080</p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">k</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1044</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1052</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">y</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1048</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1068</p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">metro</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1016</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1008</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">z</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">2000</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1000</p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">norte</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1076</p>
          </td>

          <td class="calibre21">
            <p class="calibre2">1056</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"></p>
          </td>
        </tr>
      </tbody>
    </table>

    <p class="zw"><br class="calibre1"></p>

    <table border="1" width="90%" class="calibre16">
      <tbody class="calibre20">
        <tr class="calibre18">
          <td class="calibre21">

          </td>
          <td class="calibre21">

          </td>
          <th colspan="2" class="calibre19">
            <p class="calibre2">Entero</p>
          </th>

          <th colspan="2" class="calibre19">
            <p class="calibre2">Puntero entero</p>
          </th>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">

          </td>
          <th class="calibre19">
            <p class="calibre2">expresión</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor correcto</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Dirección de Lvalue</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Valor correcto</p>
          </th>

          <th class="calibre19">
            <p class="calibre2">Dirección de Lvalue</p>
          </th>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">una.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">m</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">B.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">v + 1</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">C.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">j - 4</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">D.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">a - d</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">mi.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">v - w</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">F.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">&amp;c</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">gramo.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">&amp;e + 1</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">h.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">&amp;o - 4</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">I.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">&amp;( f + 2 )</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">j.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*g</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">k.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*k + 1</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">l.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*( n + 1 )</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">metro.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*h - 4</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">norte.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*( u – 4 )</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">o.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*f - g</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">pag.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*f - *g</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">q.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*s - *q</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">r.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*( r – t )</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">s.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">y &gt; i</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">t.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">y &gt; *i</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">u.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*y&gt;*i</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">v.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">**h</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">w.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">c++</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">X.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">++c</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">y.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*q++</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">z.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">(*q)++</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">Automóvil club británico.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*++q</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">cama y desayuno.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">++*q</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre18">
          <td class="calibre21">
            <p class="calibre2">cc.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">*++*q</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>

        <tr class="calibre22">
          <td class="calibre21">
            <p class="calibre2">dd.</p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><code class="calibre26">++*(*q)++</code></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>

          <td class="calibre21">
            <p class="calibre2"><span class="calibre29">　　　　　　</span></p>
          </td>
        </tr>
      </tbody>
    </table>

    <h2 id="nav_point_131" class="calibre24">6.18 Ejercicios de programación</h2>

    <p class="zw">★★★ 1. Escriba una función que busque en una cadena y encuentre todos los caracteres que aparecen en
      un
      conjunto de caracteres determinado. El prototipo de esta función debería ser el siguiente:</p>
    <pre class="code"><code class="calibre8">char *find_char( char const *source,
　　char const *chars );</code></pre>

    <p class="zw">Su idea básica es encontrar el primer carácter en la cadena de origen que coincida con cualquier
      carácter de la cadena de caracteres, y la función luego devuelve un puntero a la posición encontrada por la
      primera
      coincidencia en la fuente. Si todos los caracteres de la fuente no coinciden con ningún carácter de los
      caracteres,
      la función devuelve un puntero NULL. Si algún parámetro es NULL, o la cadena a la que apunta cualquier parámetro
      está vacía, la función también devuelve un puntero NULL.</p>

    <p class="zw">Por ejemplo, suponga que la fuente apunta a ABCDEF. Si chars apunta a XYZ, JURY o QQQQ, la función
      devuelve un puntero NULL. Si chars apunta a XRCQEF, la función devuelve un puntero al carácter C en la fuente. La
      cadena a la que apunta el parámetro nunca se modificará.</p>

    <p class="zw">Da la casualidad de que hay una función llamada strpbrk en la biblioteca de C, y su función es casi
      exactamente la misma que la función que desea escribir. Pero el propósito de este programa es que practique usted
      mismo la manipulación del puntero, así que:</p>

    <p class="zw">una. No debe utilizar ninguna función de biblioteca para manipular cadenas (como strcpy, strcmp,
      index,
      etc.).</p>

    <p class="zw">B. No se deben utilizar referencias de subíndice en ninguna parte de la función.</p>

    <p class="zw">★★★ 2. Escriba una función para eliminar parte de una cadena. El prototipo de la función es el
      siguiente:</p>
    <pre class="code"><code class="calibre8">　int del_substr( char *str, char const *substr )</code></pre>

    <p class="zw">La función primero debe determinar si substr aparece en str. Si no aparece, la función devuelve 0; si
      lo
      hace, la función debe copiar todos los caracteres detrás de la subcadena en str a la posición de la subcadena,
      eliminando así la subcadena, y luego la función devuelve 1. Si substr aparece en str varias veces, la función solo
      elimina la primera aparición de la subcadena. El segundo parámetro de la función nunca se modificará.</p>

    <p class="zw">Por ejemplo, suponga que str apunta a ABCDEFG. Si substr apunta a FGH, CDF o XABC, la función debe
      devolver 0 y str no se modifica. Pero si substr apunta a CDE, la función modifica str para que apunte a ABFG
      copiando los bytes F, G y NUL final a la posición de C, y luego la función devuelve 1. Pase lo que pase, el
      segundo
      parámetro de la función no debe modificarse.</p>

    <p class="zw">El procedimiento es el mismo que el de la pregunta anterior:</p>

    <p class="zw">una. No debe utilizar ninguna función de biblioteca para manipular cadenas (como strcpy, strcmp,
      etc.).
    </p>

    <p class="zw">B. No se deben utilizar referencias de subíndice en ninguna parte de la función.</p>

    <p class="zw">Vale la pena señalar que la cadena vacía es una subcadena de cada cadena, y la eliminación de una
      subcadena vacía de la cadena no cambiará.</p>

    <p class="zw hand">★★★ 3. Escribe la función reverse_string, su
      prototipo es el siguiente:</p>
    <pre class="code"><code class="calibre8">　void reverse_string( char *string );</code></pre>

    <p class="zw">La función organiza los caracteres de la cadena de parámetros en orden inverso. Utilice punteros en
      lugar de subíndices de matriz y no utilice ninguna función en la biblioteca C para manipular cadenas. <strong
        class="calibre3">Consejo: no es</strong> necesario declarar una matriz local para almacenar temporalmente
      cadenas
      de parámetros.</p>

    <p class="zw">★★★ 4. Un número primo es un número entero que solo puede ser divisible por 1 y por sí mismo. El
      método
      de cribado de Eratóstenes es un método eficaz para calcular números primos. El primer paso de este algoritmo es
      escribir todos los números enteros desde 2 hasta algún límite superior. En el resto del algoritmo, recorre la
      lista
      completa y elimina todos los enteros que no son números primos.</p>

    <p class="zw">Los siguientes pasos son así. Encuentre el primer número de la lista que no se elimine (es decir, 2) y
      luego elimine todos los números dobles detrás de la lista, porque todos son divisibles por 2, por lo que no son
      números primos. Luego, regrese al encabezado de la lista y comience de nuevo. En este momento, el primer número de
      la lista que no ha sido eliminado es 3, por lo que se elimina cada tercer número (múltiplo de 3) después de 3.
      Después de completar este paso, regrese al principio de la lista. El siguiente número después de 3 es 4, pero es
      un
      múltiplo de 2 y ha sido eliminado, por lo que se omite, es 5, y se eliminan todos los múltiplos de 5 . A esto le
      sigue la analogía, se repite, y los números que no se eliminan en la lista final son todos números primos.</p>

    <p class="zw">Escriba un programa para implementar este algoritmo y use una matriz para representar su lista. El
      valor
      de cada elemento de la matriz se utiliza para marcar si se ha eliminado el número correspondiente. Al principio,
      el
      valor de todos los elementos de la matriz se establece en VERDADERO, cuando el algoritmo requiere "eliminar" el
      número correspondiente, este elemento se establece en FALSO. Si su programa se ejecuta en una máquina de 16 bits,
      considere cuidadosamente si necesita declarar una variable como long. Al principio, use una matriz de 1000
      elementos. Si usa una matriz de caracteres y usa el mismo espacio, encontrará más números primos que una matriz de
      enteros. Puede usar subíndices para representar punteros al primer y último elemento de la matriz, pero debe usar
      punteros para acceder a los elementos de la matriz.</p>

    <p class="zw">Tenga en cuenta que, con la excepción de 2, todos los números pares no son números primos. Piénselo un
      poco, puede mejorar en gran medida la eficiencia espacial del programa, el método es que los elementos de la
      matriz
      solo corresponden a números impares. De esta manera, en el mismo espacio de matriz, el número de números primos
      que
      puede encontrar es aproximadamente el doble del número original.</p>

    <p class="zw">★★ 5. Modifique el programa de Eratóstenes en la pregunta anterior para usar matrices de bits en lugar
      de matrices de caracteres Aquí necesitamos usar la función de matriz de bits desarrollada en el Capítulo 5
      Ejercicios de programación. Esta modificación mejora aún más la eficiencia espacial del programa, pero a expensas
      de
      la eficiencia del tiempo. En su sistema, utilizando este método, ¿cuál es el número primo más grande que puede
      encontrar?</p>

    <p class="zw">★★ 6. ¿Hay tantos números primos grandes como números primos pequeños? En otras palabras, ¿hay tantos
      números primos entre 50 000 y 51 000 como números primos entre 1 000 000 y 1 001 000? ¿Usa el programa anterior
      para
      calcular cuántos números primos hay entre 0 y 1,000? ¿Cuántos números primos hay entre 1000 y 2000? Por analogía,
      cada 1 000, ¿cuántos números primos hay para 1 000 000 (o el mayor entero positivo permitido en su máquina)? ¿Cuál
      es la tendencia del número de números primos en cada 1000 números?</p>
    <hr class="calibre4">

    <p class="calibre2"><a id="anchor61" href="#ac61" class="calibre5">[1]</a> En la implementación de máquinas
      segmentadas, como Intel 80x86, se puede proporcionar una
      macro para crear constantes de puntero.</p>

    <p class="calibre2"><a id="anchor62" href="#ac62" class="calibre5">[2]</a> La excepción es para las variables
      declaradas como registro.</p>

  </div>
</body>

</html>