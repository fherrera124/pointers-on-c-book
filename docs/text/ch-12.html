<html xmlns="http://www.w3.org/1999/xhtml" class="translated-ltr">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Desconocido</title>

  <link href="../stylesheet.css" rel="stylesheet" type="text/css">
  <link href="../page_styles.css" rel="stylesheet" type="text/css">

<body id="F8900-e167752e5b154d43a225b5f350ab7738" class="calibre">
  <div class="container">
    <h1 id="nav_point_241" class="not-in-toc">Chapter 12 Using Structures and Pointers</h1>

    <p class="zw">You can create powerful data structures by combining structures and pointers. In this
      chapter we take a closer look at some techniques for using structures and pointers.
      We spend a lot of time with a data structure called a linked list, not only because it is
      very useful but also because many of the techniques used to manipulate linked lists
      are applicable to other data structures.</p>

    <h2 id="nav_point_242" class="calibre24">12.1 Linked Lists</h2>

    <p class="zw">For those of you who are not familiar with linked lists, here is a brief introduction. A
      linked list is a collection of independent structures (often called nodes) that contain data.
      The individual nodes in the list are connected by links, or pointers. A program
      accesses the nodes in the list by following the pointers. Usually the nodes are
      dynamically allocated, though occasionally you will find linked lists constructed
      among elements of an array of nodes. Even in this case, though, a program traverses
      the list by following the pointers.</p>

    <h2 id="nav_point_243" class="calibre24">12.2 Singly Linked Lists</h2>

    <p class="zw">In a singly linked list, each node contains a pointer to the next node in the list. The
      pointer field of the last node in the list contains NULL to indicate that there are no
      more nodes in the list. After you have found the first node on a list, the pointers will
      lead you to the remaining nodes. To keep track of where the list begins, a root pointer
      is used. The root pointer points to the first node on the list. Notice that the root is a
      pointer and it does not contain any data.</p>

    <p class="zw">Here is a diagram of a singly linked list.</p>

    <p class="tu"><img alt="" src="../images/00243.jpeg" class="calibre14"></p>

    <p class="zw">The nodes in this example are structures created with the following declaration.</p>
    <pre class="code"><code class="calibre8">typedef struct　NODE　 {
　　　　　struct　NODE　 *link;
　　　　　int　　　　　　　value;
} Node;</code></pre>

    <p class="zw">The data stored in each node is an integer. This list contains three nodes. If you begin
      at the root and follow the pointer to the first node, you can access the data stored in
      that node. Following the pointer in the first node takes you to the second node, where
      you can get its data. Finally, the next pointer brings you to the last node. The value
      zero is used to indicate a NULL pointer; here it means that there are no more nodes in
      the list.</p>

    <p class="zw">In the diagram the nodes are shown as adjacent to display the logical ordering
      that the links provide. In fact, the nodes might actually be scattered all through
      memory. It doesn't make any difference to a program processing such a list whether
      the nodes are physically adjacent or not, because the program always uses the links to
      get from one node to the next.</p>

    <p class="zw">A singly linked list can be traversed from start to end by following the links,
      but the list cannot be traversed backwards. In other words, once your program has
      reached the last node in the list, the only way to get back to any earlier node is to start
      again from the root pointer. Of course, the program could save a pointer to the current
      node before advancing to the next one, or it could even save pointers to the preceding
      few nodes. However, these linked lists are dynamic and can grow to hold hundreds
      or thousands of nodes, so it is not feasible to save pointers to all of the preceding
      nodes in a list.</p>

    <p class="zw">The nodes in this particular list are linked so that the data values are in
      ascending order. This ordering is important for some applications, such as organizing
      appointments by time of day. It is also possible to create an unordered list for
      applications that do not require any ordering.</p>

    <h3 id="nav_point_244" class="calibre7">12.2.1 Inserting into a Singly Linked List</h3>

    <p class="zw">How would we insert a new node into an ordered singly linked list? Suppose we had
      a new value, say 12, to insert into the previous list. Conceptually this task is easy: start
      at the beginning of the list, follow the pointers until you find the first node whose
      value is larger than 12, and then insert the new value into the list just before that node.
    </p>

    <p class="zw">In practice the algorithm is more interesting. We traverse the list and stop when
      we reach the node containing 15, the first value greater than 12. We know that the new
      value should be added to the list just before this node, but the pointer field of the
      <strong class="calibre3">previous</strong> node must be modified to accomplish the insertion. However, we've
      passed
      this node, and we cannot go back. The solution is to always save a pointer to the
      previous node in the list.
    </p>

    <p class="zw">We will now develop a function to insert a node into an ordered, singly linked
      list. Program 12.1 is our first attempt.</p>
    <pre class="code"><code class="calibre8">/* 
** Insert into an ordered, singly linked list. The arguments are
** a pointer to the first node in the list, and the value to
** insert.
*/
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include "sll_node.h"

#define　　FALSE　　 0
#define　　TRUE　　　1

int
sll_insert( Node *current, int new_value )
{
  Node　 *previous;
  Node　 *new;

  /*
  ** Look for the right place by walking down the list
  ** until we reach a node whose value is greater than
  ** or equal to the new value.
  */
  while( current-&gt;value &lt; new_value ){
  　　　previous = current;
  　　　current = current-&gt;link;
  }

  /* 
  ** Allocate a new node and store the new value into it.
  ** In this event, we return FALSE.
  */
  new = (Node *)malloc( sizeof( Node ) );
  if( new == NULL )
  　　　return FALSE;
  new-&gt;value = new_value;

  /*
  ** Insert the new node into the list, and return TRUE.
  */
  new-&gt;link = current;
  previous-&gt;link = new;
  return TRUE;
}</code></pre>

    <p class="calibre2"><strong class="calibre3">Program 12.1 Insert into an ordered, singly linked list: first
        try</strong></p>

    <p class="calibre11">insert1.c</p>

    <p class="zw">We call the function in this manner:</p>
    <pre class="code"><code class="calibre8">result = sll_insert( root, 12 );</code></pre>

    <p class="zw">Let's trace this code and see whether it correctly inserts the new value 12 into
      the list. First, the function is called with the value of the root variable, a pointer to the
      first node in the list. Here is the state of the list when the function begins:</p>

    <p class="tu"><img alt="" src="../images/00244.jpeg" class="calibre14"></p>

    <p class="zw">This diagram does not show the root variable because the function cannot access it. A
      copy of its value came into the function as the parameter current, but the function
      cannot access root. Now current-&gt;value is 5, which is less than 12, so the body of the
      loop is executed once. When we get back to the top of the loop, our pointers will have
      advanced.</p>

    <p class="tu"><img alt="" src="../images/00245.jpeg" class="calibre14"></p>

    <p class="zw">current-&gt;value is now 10, so the body of the loop executes again, with this result:</p>

    <p class="tu"><img alt="" src="../images/00246.jpeg" class="calibre14"></p>

    <p class="zw">Now current-&gt;value is greater than 12 so the loop breaks.</p>

    <p class="zw">At this point the previous pointer is the important one, because it points to the
      node that must be changed to insert the new value. But first, a new node must be
      obtained to hold the value. The next diagram shows the state of the list after the value
      is copied into the new node.</p>

    <p class="tu"><img alt="" src="../images/00247.jpeg" class="calibre14"></p>

    <p class="zw">Linking the new node into the list requires two steps. First,</p>
    <pre class="code"><code class="calibre8">new-&gt;link = current;</code></pre>

    <p class="calibre2">makes the new node point to what will be the next node in the list, the first one we
      found with a value larger than 12. After this step, the list looks like this:</p>

    <p class="tu"><img alt="" src="../images/00248.jpeg" class="calibre14"></p>

    <p class="zw">The second step is to make the previous node, the last one whose value was smaller
      than 12, point to the new node. The following statement performs this task.</p>
    <pre class="code"><code class="calibre8">previous-&gt;link = new;</code></pre>

    <p class="zw">The result of this step is:</p>

    <p class="tu"><img alt="" src="../images/00249.jpeg" class="calibre14"></p>

    <p class="zw">The function then returns, leaving the list looking like this:</p>

    <p class="tu"><img alt="" src="../images/00250.jpeg" class="calibre14"></p>

    <p class="zw">Starting at the root pointer and following the links verifies that the new node has been
      correctly inserted.</p>

    <h5 class="sigil_not_in_toc">Debugging the Insert Function</h5>

    <p class="calibre2"><br class="calibre1"></p>

    <p class="editing-tag">CAUTION!</p>

    <blockquote class="ti_shi">
      <p class="zw"><br class="calibre1"></p>

      <p class="calibre2">Unfortunately, the insert function is incorrect. Try inserting the value 20 into the list
        and you will see one problem: the while loop runs off the end of the list and then
        applies indirection to a NULL pointer. To solve this problem, we must test current to
        make sure that it is not NULL before evaluating current-&gt;value:</p>
    </blockquote>
    <pre class="code"><code class="calibre8">while( current != NULL &amp; current-&gt;value &lt; value ){</code></pre>

    <p class="zw">The next problem is tougher. Trace the function to insert the value 3 into the
      list. What happens?</p>

    <p class="zw">In order to add a node to the beginning of the list, the function must change the
      root pointer. The function, however, cannot access the variable root. The easiest way
      to fix this problem is to just make root a global variable so that the insertion function
      can modify it. Unfortunately, this approach is also the <strong class="calibre3">worst</strong> way to fix the
      problem, because then the function works only for that one list.</p>

    <p class="zw">The better solution is to pass a pointer to root as an argument. Then the
      function can use indirection both to obtain the value of root (the pointer to the first
      node of the list), and to store a new pointer into it. What is the type of this parameter?
      root is a pointer to a Node, so the parameter is of type Node **: a pointer to a pointer to
      a Node. The function in Program 12.2 contains these modifications. We must now call
      the function like this:</p>
    <pre class="code"><code class="calibre8">result = sll_insert( &amp;root, 12 );

/* 
** Insert into an ordered, singly linked list. The arguments are
** a pointer to the root pointer for the list, and the value to
** insert.
*/
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include "sll_node.h"

#define　 FALSE　0
#define　 TRUE　　1

int
sll_insert( Node **rootp, int new_value )
{
　　　 Node　*current;
　　　 Node　*previous;
　　　 Node　*new;

　　　 /*
　　　 ** Get the pointer to the first node.
　　　 */
　　　 current = *rootp;
　　　 previous = NULL;

　　　 /* 
　　　 ** Look for the right place by walking down the list
　　　 ** until we reach a node whose value is greater than
　　　 ** or equal to the new value.
　　　 */
　　　 while( current != NULL &amp;&amp; current-&gt;value &lt; new_value ){
　　　　　　 previous = current;
　　　　　　 current = current-&gt;link;
　　　 }

　　　 /*
　　　 ** Allocate a new node and store the new value into it.
　　　 ** In this event, we return FALSE.
　　　 */
　　　 new = (Node *)malloc( sizeof( Node ) );
　　　 if( new == NULL )
　　　　　 return FALSE;
　　　 new-&gt;value = new_value;

　　　 /* 
　　　 ** Insert the new node into the list, and return TRUE.
　　　 */
　　　 new-&gt;link = current;
　　　 if( previous == NULL )
　　　　　 *rootp = new;
　　　 else
　　　　　 previous-&gt;link = new;
　　　 return TRUE;
}</code></pre>

    <p class="calibre2"><strong class="calibre3">Program 12.2 Insert into an ordered, singly linked list: second
        try</strong>　</p>

    <p class="calibre11">insert2.c</p>

    <p class="zw">This second version contains some additional statements.</p>
    <pre class="code"><code class="calibre8">previous = NULL；</code></pre>

    <p class="zw">is needed so that we can check later whether the new value will be the first node in the
      list.</p>
    <pre class="code"><code class="calibre8">current = *rootp;</code></pre>

    <p class="zw">uses indirection on the root pointer argument to get the value of root, a pointer to the
      first node in the list. Finally</p>
    <pre class="code"><code class="calibre8">If (previous == NULL)
　　　　　*rootp = new;
else
　　　　　previous-&gt;link = new;</code></pre>

    <p class="zw">was added to the end of the function. It checks whether the new value should be
      added to the beginning of the list. If so, we use indirection on the root pointer to make
      root point to the new node.</p>

    <p class="zw">This function works, and in many languages it is as good as you can get.
      However, we can do better because C allows you to get the address of (a pointer to)
      existing objects.</p>

    <h5 class="sigil_not_in_toc">Optimizing the Insert Function</h5>

    <p class="zw">It appears that inserting a node at the beginning of the list <strong class="calibre3">must</strong>
      be
      a special case. After
      all, the pointer that must be adjusted to insert the first node is the root pointer. For
      every other node, the pointer to be adjusted is the link field of the previous node.
      These seemingly different operations are really the same.</p>

    <p class="zw">The key to eliminating the special case is to realize that every node in the list
      has a pointer somewhere pointing to it. For the first node, it is the root pointer, and for
      every other node it is the link field of the preceding node. The important point is that
      there is a pointer somewhere pointing to each node. Whether the pointer is or is not
      contained in a node is irrelevant.</p>

    <p class="zw">Let's look at the list once more to clarify this point. Here is the first node and its
      corresponding pointer.</p>

    <p class="tu"><img alt="" src="../images/00251.jpeg" class="calibre14"></p>

    <p class="zw">If the new value is inserted before the first node, then this pointer must be changed.</p>

    <p class="zw">Here is the second node and its pointer.</p>

    <p class="tu"><img alt="" src="../images/00252.jpeg" class="calibre14"></p>

    <p class="zw">If the new value is inserted before the second node, then this pointer must be changed.
      Note that we're concerned only with the pointer; the node that contains it is irrelevant.
      The same pattern holds for every node in the list.</p>

    <p class="zw">Now let's take a look at the modified function as it begins to execute. Here are
      its variables as they appear just after the first assignment statement.</p>

    <p class="tu"><img alt="" src="../images/00253.jpeg" class="calibre14"></p>

    <p class="zw">We have a pointer to the current node and a pointer to the link that points to the
      current node. We don't need anything else! If the value in the current node is larger
      than the new value, the rootp pointer tells us which link field must be changed to link
      the new node into the list. If insertions elsewhere in the list can be expressed the same
      way, the special case disappears. The key is the pointer/node relationship we saw
      earlier.</p>

    <p class="zw">When moving to the next node, save a pointer to the <strong class="calibre3">link</strong> that points
      to the next
      node instead of keeping a pointer to the previous <strong class="calibre3">node</strong>. It is easy to diagram
      what
      is
      desired.

    </p>

    <p class="tu"><img alt="" src="../images/00254.jpeg" class="calibre14"></p>

    <p class="zw">Notice here that rootp is not pointing to the node; it points to the link field within the
      node. This fact is the key to simplifying the insert function, but it depends upon our
      being able to obtain the address of the link field of the current node. This operation is
      easy in C. The expression &amp;current-&gt;link does the trick. Program 12.3 is the final
      version of our insertion function. The rootp parameter is now called linkp, because it
      points to many different links now, not just the root. We don't need previous any
      more, because our link pointer takes care of locating the link that needs to be
      modified. The special case at the end of the function is gone because we always have a
      pointer to the link field that needs to be changed—we modify the root variable in
      exactly the same way as the link field of a node. Finally, register declarations have
      been added to the pointer variables to improve the efficiency of the resulting code. </p>

    <p class="zw">The while loop in this final version is trickier because of the embedded
      assignment to current. Here is an equivalent, though slightly longer loop.</p>
    <pre class="code"><code class="calibre8">/*
** Look for the right place.
*/
current = *linkp;
while( current !=NULL &amp;&amp; current-&gt;value &lt; value ){
　　　　　linkp = &amp;current-&gt;link;

current = * linkp;
}</code></pre>

    <p class="zw">To begin, current is set to point to the first node in the list. The while test checks
      whether we've reached the end of the list. If not, it then checks whether we are at the
      proper place for the insertion. If not, the body of the loop executes, which sets linkp to
      point to the link field in the current node, and advances current to the next node.</p>

    <p class="zw">The fact that the last statement in the loop body is identical to the statement just
      prior to the loop leads to the "simplification" of embedding the assignment to current
      within the while expression. The result is a more complex but more compact loop,
      because we have eliminated the redundant assignment to current.</p>
    <pre class="code"><code class="calibre8">/*
** Insert into an ordered, singly linked list. The arguments are
** a pointer to the first node in the list, and the value to
** insert.
*/
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include "sll_node.h"

#define　 FALSE　0
#define　 TRUE　　1

int
sll_insert( register Node **linkp, int new_value )
{
　　 register Node　*current;
　　 register Node　*new;

　　 /* 
　　 ** Look for the right place by walking down the list
　　 ** until we reach a node whose value is greater than
　　 ** or equal to the new value.
　　 */
　　 while( ( current = *linkp ) != NULL &amp;&amp;
　　　　 current-&gt;value &lt; new_value )
　　　　　 linkp = &amp;current-&gt;link;

　　 /* 
　　 ** Allocate a new node and store the new value into it.
　　 ** In this event, we return FALSE.
　　 */
　　 new = (Node *)malloc( sizeof( Node ) );
　　 if( new == NULL )
　　　　　return FALSE;
　　 new-&gt;value = new_value;

　　 /* 
　　 ** Insert the new node into the list, and return TRUE.
　　 */
　　 new-&gt;link = current;
　　 *linkp = new;
　　 return TRUE;
}</code></pre>

    <p class="calibre2"><strong class="calibre3">Program 12.3 Insert into an ordered, singly linked list: final
        version</strong></p>

    <p class="calibre11">insert3.c</p>

    <p class="editing-tag">TIP</p>

    <blockquote class="ti_shi">
      <p class="zw"><br class="calibre1"></p>

      <p class="calibre2">Eliminating the special case made this function simpler. There are two factors that
        make this improvement possible. The first factor is our ability to interpret the problem
        correctly. Unless you can identify the commonality in seemingly different operations,
        you will be stuck writing extra code to handle special cases. Often this knowledge is
        acquired only after you have worked with the data structure for a while and
        understand it more clearly. The second factor is that the C language provides the right
        tools for you to exploit the commonality.</p>

      <p class="calibre2">The improved function depends on C's ability to obtain the address of existing
        objects. Like many C features, this ability is both powerful and dangerous. In Modula
        and Pascal, for example, there isn't an "address of" operator, so the only pointers that
        exist are those produced by dynamic memory allocation. It is not possible to obtain a
        pointer to an ordinary variable or even to a field of a dynamically allocated structure.
        Pointer arithmetic is not allowed, and there isn't any means for casting a pointer from
        one type to another. These restrictions are advantageous in that they prevent the
        programmer from making mistakes such as subscripting off the end of an array and
        generating pointers of one type that in fact point to objects of some other type.
      </p>
    </blockquote>

    <p class="zw"><br class="calibre1"></p>

    <p class="editing-tag">CAUTION!</p>

    <blockquote class="ti_shi">
      <p class="zw"><br class="calibre1"></p>

      <p class="calibre2">There are far fewer restrictions on pointers in C, which is why we were able to
        improve the insertion function. On the other hand, C programmers must be more
        careful when using pointers to avoid mistakes. The Pascal philosophy to pointers is
        sort of like saying, "You might hurt yourself with a hammer, so we won't give you
        one." The C philosophy is, "Here is a hammer. In fact, here are several kinds of
        hammers. Good luck." With this power, C programmers can get into more trouble
        than Pascal programmers, but good C programmers can produce smaller, more
        efficient, and more maintainable code than their Pascal or Modula counterparts. This
        is one of the reasons why C is so popular in industry, and why experienced C
        programmers are in such demand.</p>
    </blockquote>

    <h3 id="nav_point_245" class="calibre7">12.2.2 Other List Operations</h3>

    <p class="zw">To make singly linked lists really useful, we need more operations such as searching
      and deletion. However, the algorithms for these operations are straightforward and
      easily implemented using the techniques illustrated in the insertion function. These
      functions are left as exercises.</p>

    <h2 id="nav_point_246" class="calibre24">12.3 Doubly Linked Lists</h2>

    <p class="zw">An alternative to singly linked lists is the doubly linked list. In a doubly linked list, each
      node has two pointers—one to the next node in the list and one to the previous node.
      The back pointer lets us traverse doubly linked lists in either direction. We can even go
      back and forth. The following diagram illustrates a doubly linked list.</p>

    <p class="tu"><img alt="" src="../images/00255.jpeg" class="calibre14"></p>

    <p class="zw">Here is the declaration for the node type.</p>
    <pre class="code"><code class="calibre8">typedf struct　NODE　 {
　　　　struct　NODE　 *fwd;
　　　　struct　NODE　 *bwd;
　　　　int　　　　　　　value;
} Node;</code></pre>

    <p class="zw">The root is now two pointers: one points to the first node in the list, and the other
      points to the last node. These two pointers let us begin a traversal at either end of the
      list.</p>

    <p class="zw">We might declare the two root pointers as separate variables, but then we
      would have to pass pointers to both of them to the insertion function. It is more
      convenient to declare an entire node for the root pointers, one whose value field is
      never used. In our example, this technique only wastes the memory for one integer. Separate pointers might be
      better for lists whose value field is large. Alternatively, we
      might use the value field of the root node to store other information about the list, for
      example, the number of nodes it currently contains.</p>

    <p class="zw">The fwd field of the foot node points to the first node in the Use, and the bwd
      field of the root node points to the last node in the list. Both of these fields will be
      NULL if the list is empty. The bwd field of the first node in the list and the fwd field of
      the last node will be NULL. In an ordered list, nodes are stored in increasing order of
      the value field.</p>

    <h3 id="nav_point_247" class="calibre7">12.3.1 Inserting into a Doubly Linked List</h3>

    <p class="zw">This time, we develop a function that inserts a value into an ordered, doubly linked
      list. dll_insert takes two arguments: a pointer to the root node and an integer value.</p>

    <p class="zw">The singly linked insertion function we wrote earlier adds duplicate values to
      the list. It may be more appropriate for some applications to not add duplicates.
      dll_insert will add a new value only if is not already in the list.</p>

    <p class="zw">Let's take a more disciplined approach to developing this function. There are
      four cases that can occur when inserting a node into a linked list:</p>

    <p class="zw">1. The value might have to be inserted in the middle of the list.</p>

    <p class="zw">2. The value might have to be inserted at the beginning of the list.</p>

    <p class="zw">3. The value might have to be inserted at the end of the list</p>

    <p class="zw">4. The value might have to be inserted at both the beginning and the end (that is,
      inserted into an empty list).</p>

    <p class="zw">In each of these cases, four pointers must be modified.</p>

    <ul class="calibre35">
      <li class="di_1ji_wu_xu_lie_biao">In cases (1) and (2), the fwd field of the new node must be set to point to the
        next node in the list, and the bwd field of the next node in the list must be set to point to
        the new node. In cases (3) and (4), the fwd field of the new node must be set to
        NULL, and the bwd field of the root node must be set to point to the new node.</li>

      <li class="di_1ji_wu_xu_lie_biao">In cases (1) and (3), the bwd field of the new node must be set to point to the
        previous node in the list, and the fwd field of the previous node must be set to
        point to the new node. In cases (2) and (4), the bwd field of the new node must be
        set to NULL, and the fwd field of the root node must be set to point to the new
        node.</li>
    </ul>

    <p class="zw">If this description seems unclear, the straightforward implementation in Program 12.4
      should help.</p>
    <pre class="code"><code class="calibre8">/* 
** Insert a value into a doubly linked list. rootp is a pointer to
** the root node, and value is the new value to be inserted.
** Returns: 0 if the value is already in the list, -1 if there was
** no memory to create a new node, 1 if the value was added
** successfully.
*/
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include "doubly_linked_list_node.h"

int
dll_insert( Node *rootp, int value )
{
　　 Node　*this;
　　 Node　*next;
　　 Node　*newnode;

　　 /* 
　　 ** See if value is already in the list; return if it is.
　　 ** Otherwise, allocate a new node for the value (&quot;newnode&quot;
　　 ** will point to it). &quot;this&quot; will point to the node that the
　　 ** new value should follow, and &quot;next&quot; will point to the one
　　 ** after it.
　　 */
　　 for( this = rootp; (next = this-&gt;fwd) != NULL; this = next ){
　　　　　 if( next-&gt;value == value )
　　　　　　return 0;
　　　 if( next-&gt;value &gt; value )
　　　　　　 break;
}
newnode = (Node *)malloc( sizeof( Node ) );
if( newnode == NULL )
　　return -1;
newnode-&gt;value = value;

/* 
** Add the new node to the list.
*/
if( next != NULL ){
/* 
** Case 1 or 2: not at end of the list
*/
　　　　　 if( this != rootp ){　　　/* Case 1: not at front */
　　　　　　　　 newnode-&gt;fwd = next;
　　　　　　　　 this-&gt;fwd = newnode;
　　　　　　　　 newnode-&gt;bwd = this;
　　　　　　　　 next-&gt;bwd = newnode;
　　　　　 }
　　　　　 else {　　　　　　　　　　　　　/* Case 2: at front */
　　　　　　　　 newnode-&gt;fwd = next;
　　　　　　　　 rootp-&gt;fwd = newnode;
　　　　　　　　 newnode-&gt;bwd = NULL;
　　　　　　　　 next-&gt;bwd = newnode;
　　　　　 }
　　}
　　else {
　　/* 
　　** Case 3 or 4: at end of the list
　　*/
　　　　　 if( this != rootp ){　　/* Case 3: not at front */
　　　　　　　　 newnode-&gt;fwd = NULL;
　　　　　　　　 this-&gt;fwd = newnode;
　　　　　　　　 newnode-&gt;bwd = this;
　　　　　　　　 rootp-&gt;bwd = newnode;
　　　　　 }
　　　　　 else {　　　　　　　　　　　　 /* Case 4: at front */
　　　　　　　　 newnode-&gt;fwd = NULL;
　　　　　　　　 rootp-&gt;fwd = newnode;
　　　　　　　　 newnode-&gt;bwd = NULL;
　　　　　　　　 rootp-&gt;bwd = newnode;
　　　　　 }
　　}
　　return 1;
}</code></pre>

    <p class="calibre2"><strong class="calibre3">Program 12.4 Straightforward doubly linked list insert
        function</strong></p>

    <p class="calibre11">dll_ins1.c</p>

    <p class="zw">The function begins by making this point to the root node. The next pointer
      always points to the node after this; the idea is to advance these pointers together
      until the new node should be inserted between them. The for loop checks the value in
      the next node to determine when this position has been reached.</p>

    <p class="zw">If the new value is found in the list, the function simply returns. Otherwise, the
      loop ends when the end of the list is reached or when the proper position for insertion
      is reached. In either case, the new node should be inserted after the this node. Note
      that space for the new node is not allocated until after we determine whether the value
      should actually be added to the list. Allocating the new node first would cause a potential memory leak for
      duplicate
      values.</p>

    <p class="zw">The four cases have been implemented separately. Let's trace case 1 by inserting
      the value 12 into the list. The following diagram shows the state of our variables just
      after the for loop breaks.</p>

    <p class="tu"><img alt="" src="../images/00256.jpeg" class="calibre14"></p>

    <p class="zw">A new node is then allocated. After executing the statements</p>
    <pre class="code"><code class="calibre8">newnode-&gt;fwd = next;
this-&gt;fwd = newnode;</code></pre>

    <p class="zw">the list looks like this:</p>

    <p class="tu"><img alt="" src="../images/00257.jpeg" class="calibre14"></p>

    <p class="zw">Then, the statements</p>
    <pre class="code"><code class="calibre8">newnode-&gt;bwd = this;
　　 next-&gt;bwd = newnode;</code></pre>

    <p class="zw">finish linking the new value into the list:</p>

    <p class="tu"><img alt="" src="../images/00258.jpeg" class="calibre14"></p>

    <p class="zw">Study the code to determine how the remaining cases work, and convince yourself
      that each case is completed properly.</p>

    <h5 class="sigil_not_in_toc">Simplifying the Insert Function</h5>

    <p class="zw"><br class="calibre1"></p>

    <p class="editing-tag">TIP</p>

    <blockquote class="ti_shi">
      <p class="zw"><br class="calibre1"></p>

      <p class="calibre2">The observant programmer will notice that there is a lot of similarity among the
        groups of statements in the nested if statements in the function, and the good
        programmer will be bothered by all of the duplication. So we will now eliminate the
        duplication using two techniques. The first is statement factoring, and is illustrated in
        the following example.</p>
    </blockquote>
    <pre class="code"><code class="calibre8">if( x == 3) {
　　　　　i = 1;
　　　　　something;
　　　　　j = 2;
}
else {
　　　　　i = 1;
　　　　　something different;
　　　　　j = 2;
}</code></pre>

    <blockquote class="ti_shi">
      <p class="calibre2">Notice that the statements i = 1; and j = 2; will be executed whether the expression
        x == 3 is true or false. Doing i = 1; before the if will not affect the result of the test
        x == 3, so both pairs of assignments can be factored out, leaving the simpler, but
        completely equivalent, statements:</p>
    </blockquote>
    <pre class="code"><code class="calibre8">i = 1；
if( x == 3 )
　　　　　something;
else
　　　　　something different;
j = 2;</code></pre>

    <p class="editing-tag">CAUTION!</p>

    <blockquote class="ti_shi">
      <p class="zw"><br class="calibre1"></p>

      <p class="calibre2">Be careful not to factor a statement above the if that changes the result of the test. For
        example, in</p>
    </blockquote>
    <pre class="code"><code class="calibre8">if( x == 3 ){
　　　　　x = 0;
　　　　　something;
}
else {
　　　　　x = 0;
　　　　　something different;
}</code></pre>

    <blockquote class="ti_shi">
      <p class="calibre2">the statement x = 0; cannot be factored out because it would affect the result of the
        comparison.</p>
    </blockquote>

    <p class="zw">Factoring the innermost of the nested if's in Program 12.4 yields the code
      fragment in Program 12.5. Compare this code to the previous function and convince
      yourself that it is equivalent.</p>
    <pre class="code"><code class="calibre8">/*　
** Add the new node to the list.
*/
if( next != NULL ){
　　/* 
　　** Case 1 or 2: not at end of the list
　　*/
　　　　　newnode-&gt;fwd = next;
　　　　　if( this != rootp ){　　 /* Case 1: not at front */
　　　　　　　 this-&gt;fwd = newnode;
　　　　　　　 newnode-&gt;bwd = this;
　　　　　}
　　　　　else {　　　　　　　　　　　　 /* Case 2: at front */
　　　　　　　 rootp-&gt;fwd = newnode;
　　　　　　　 newnode-&gt;bwd = NULL;
　　　　　}
　　　　　next-&gt;bwd = newnode;
}
else {
　　　/* 
　　　** Case 3 or 4: at end of the list
　　　*/
　　　　　newnode-&gt;fwd = NULL;
　　　　　if( this != rootp ){　/* Case 3: not at front */
　　　　　　　 this-&gt;fwd = newnode;
　　　　　　　 newnode-&gt;bwd = this;
　　　　　}
　　　　　else {　　　　　　　　　　　 /* Case 4: at front */
　　　　　　　 rootp-&gt;fwd = newnode;
　　　　　　　 newnode-&gt;bwd = NULL;
　　　　　}
　　　　　rootp-&gt;bwd = newnode;
　　　　　}</code></pre>

    <p class="calibre2"><strong class="calibre3">Program 12.5 Factored doubly linked list insertion logic</strong></p>

    <p class="calibre11">dll_ins2.c</p>

    <p class="zw">The second simplification technique is easily illustrated with an example:
    </p>
    <pre class="code"><code class="calibre8">if( pointer !=NULL )
　　　　 field = pointer;
else
　　　　 fileld = NULL;</code></pre>

    <p class="zw">The intent here is to set a variable equal to pointer, or to NULL if pointer doesn't
      point to anything. But look at this statement:</p>
    <pre class="code"><code class="calibre8">field = pointer;</code></pre>

    <p class="zw">If pointer is not NULL, field gets a copy of its value, as before. But if pointer is NULL, field gets
      a copy of the NULL from pointer, which has the same effect as
      assigning the constant NULL. This statement performs the same work as the previous
      one and is obviously simpler.</p>

    <p class="zw">The key to applying this technique to the code in Program 12.5 is to identify the
      statements that perform the same work even though they look different and rewrite
      them so that they are identical. We can rewrite the first statement in cases 3 and 4 as</p>
    <pre class="code"><code class="calibre8">newnode-&gt;fwd = next;</code></pre>

    <p class="zw">because the if statement has just determined that next == null. This change makes
      the first statement on both sides of the if statement identical, so we can factor it out.
      Write down this change, and study what remains.</p>

    <p class="zw">Did you see it? Both nested if's are now identical, so they can also be factored.
      The result of these changes is shown in Program 12.6.</p>

    <p class="zw">We can improve this code still further. The first statement in the else clause of
      the first if can be rewritten as</p>
    <pre class="code"><code class="calibre8">this-&gt;fwd = newnode;</code></pre>

    <p class="zw">because the if statement has already decided that this == rootp. The rewritten
      statement and its mate can now be factored out, too.</p>

    <p class="zw">Program 12.7 is the entire function after all of the changes have been
      implemented. It does the same work as the original but is much smaller. The local
      pointers have been declared register variables to improve the size and speed of the
      code even further.</p>
    <pre class="code"><code class="calibre8">/* 
** Add the new node to the list. 
*/
newnode-&gt;fwd = next;

if( this != rootp ){
　　　this-&gt;fwd = newnode;
　　　newnode-&gt;bwd = this;
}
else {
　　　rootp-&gt;fwd = newnode;
　　　newnode-&gt;bwd = NULL;
}
if( next != NULL )
　　　next-&gt;bwd = newnode;
else
　　　rootp-&gt;bwd = newnode;</code></pre>

    <p class="calibre2"><strong class="calibre3">Program 12.6 Further factored doubly linked list insertion
        logic</strong>　</p>

    <p class="calibre11">dll_ins3.c</p>
    <pre class="code"><code class="calibre8">　　/* 
　　** Insert a value into a doubly linked list. rootp is a pointer to
　　** the root node, and value is the new value to be inserted.
　　** Returns: 0 if the value is already in the list, -1 if there was
　　** no memory to create a new node, 1 if the value was added
　　** successfully. 
　　*/
　　#include &lt;stdlib.h&gt;
　　#include &lt;stdio.h&gt;
　　#include "doubly_liked_list_node.h"

　　int
　　dll_insert( register Node *rootp, int value )
　　{
　　　　 register Node　*this;
　　　　 register Node　*next;
　　　　 register Node　*newnode;

　　　　 /* 
　　　　 ** See if value is already in the list; return if it is.
　　　　 ** Otherwise, allocate a new node for the value (&quot;newnode&quot;
　　　　 ** will point to it). &quot;this&quot; will point to the node that the
　　　　 ** new value should follow, and &quot;next&quot; will point to the one
　　　　 ** after it.
　　　　 */
　　　　 for( this = rootp; (next = this-&gt;fwd) != NULL; this = next ){
　　　　　　　 if( next-&gt;value == value )
　　　　　　　　　　return 0;
　　　　　　　　if( next-&gt;value &gt; value )
　　　　　　　　　　break;
　　　　 }
　　　　 newnode = (Node *)malloc( sizeof( Node ) );
　　　　 if( newnode == NULL )
　　　　　　　　return -1;
　　　　 newnode-&gt;value = value;

　　　　 /* 
　　　　 ** Add the new node to the list.
　　　　 */
　　　　 newnode-&gt;fwd = next;
　　　　 this-&gt;fwd = newnode;

　　　　 if( this != rootp )
　　　　　　　newnode-&gt;bwd = this;
　　　　 else
　　　　　　　newnode-&gt;bwd = NULL;

　　　　 if( next != NULL )
　　　　　　　next-&gt;bwd = newnode;
　　　　 else
　　　　　　　rootp-&gt;bwd = newnode;

　　　　 return 1;
}</code></pre>

    <p class="calibre2"><strong class="calibre3">Program 12.7 Fully simplified doubly linked list insertion
        function</strong></p>

    <p class="calibre11">dll_ins4.c</p>

    <p class="zw">This function cannot be made significantly better, though we can make the source
      code smaller. The purpose of the first if statement is to determine the right side of an
      assignment. We can replace the if with a conditional expression. We can also replace
      the second if with a conditional, though this change is less obvious.</p>

    <p class="editing-tag">TIP:</p>

    <blockquote class="ti_shi">
      <p class="zw"><br class="calibre1"></p>

      <p class="calibre2">The code in Program 12.8 is certainly smaller, but is it really better? Although there are
        fewer statements, the number of comparisons and assignments that must be made is
        the same as before, so this code isn't any faster than what we had before. There are two
        minor differences: newnode-&gt;bwd and -&gt;bwd = newnode are both written once rather
        than twice. Will these differences result in smaller code? Possibly, depending on how
        well your compiler can optimize. But the difference will be small at best, and this code
        is less readable than before, particularly for an inexperienced C programmer. Thus,
        Program 12.8 may be more trouble to maintain.</p>

      <p class="calibre2">If the program size or execution speed were really important, the only thing left
        to try would be to hand code the function in assembly language. Even this drastic
        option does not guarantee any significant improvement, and the difficulty of writing,
        reading, and maintaining assembly code suggests that this approach should be used
        only as a last resort.</p>
    </blockquote>
    <pre class="code"><code class="calibre8">/* 
** Add the new node to the list.
*/
newnode-&gt;fwd = next;
this-&gt;fwd = newnode;
newnode-&gt;bwd = this != rootp ? this : NULL;
( next != NULL ? next : rootp )-&gt;bwd = newnode;</code></pre>

    <p class="calibre2"><strong class="calibre3">Program 12.8 Insert function using conditional expressions</strong></p>

    <p class="calibre11">dll_ins5.c</p>

    <h3 id="nav_point_248" class="calibre7">12.3.2 Other List Operations</h3>

    <p class="zw">As with singly linked lists, more operations are needed for doubly linked lists. The
      exercises will give you practice in writing them.</p>

    <h2 id="nav_point_249" class="calibre24">12.4 Summary</h2>

    <p class="zw">A singly linked list is a data structure that stores values using pointers. Each node in
      the list contains a field which points to the next node. A separate pointer, called the
      root, points to the first node. When the nodes are dynamically allocated, they may be
      scattered throughout memory. However, the list is traversed by following the
      pointers, so the physical arrangement of the nodes is irrelevant. A singly linked list
      can only be traversed in one direction.</p>

    <p class="zw">To insert a new value into an ordered, singly linked list, you must first find the
      proper position in the list. New values may be inserted into unordered lists anywhere.
      There are two steps to link a new node into the list. First, the new node's link field
      must be set to point to what will be the next node. Second, the previous link field must
      be changed to point to the new node. In many other languages, an insertion function
      would save a pointer to the previous node to accomplish the second step. However,
      this technique makes inserting at the beginning of the list a special case. In C, you can
      eliminate the special case by saving a pointer to the link field that must be changed
      instead of a pointer to the previous node.</p>

    <p class="zw">Each node in a doubly linked list contains two link fields: one points to the next
      node in the list, and the other points to the previous node. Two root pointers are used
      to point to the first and the last nodes in the list. Thus, traversals of doubly linked lists
      may begin from either end of the list and may proceed in either direction. To insert a
      new node into a doubly linked list, four links must be changed. The new node's
      forward and backward links must be set, and the previous node's forward pointer and
      the next node's backward pointer must both be changed to point to the new node.</p>

    <p class="zw">Statement factoring is a technique that simplifies a program by removing
      redundant statements from it. If the "then" and the "else" clauses of an if end with
      identical sequences of statements, they can be replaced by a single copy of the
      sequence after the if. Identical sequences of statements can also be factored from the
      beginning of an if statement unless their execution changes the test performed by the
      if. If different statements actually perform the same work, you may be able to rewrite
      them identically. You may then be able to apply statement factoring to simplify the
      program.</p>

    <h2 id="nav_point_250" class="calibre24">12.5 Summary of Cautions</h2>

    <p class="zw">1. Falling off the end of a linked list (page 327).</p>

    <p class="zw">2. Be especially careful with pointers, because C does not provide a safety net for
      their use (page 333).</p>

    <p class="zw">3. Factoring a statement out of an if that changes the result of the test (page 340).</p>

    <h2 id="nav_point_251" class="calibre24">12.6 Summary of Programming Tips</h2>

    <p class="zw">1. Eliminating special cases makes code easier to maintain (page 333).</p>

    <p class="zw">2. Eliminate duplicate statements from if statements by factoring them (page 339).</p>

    <p class="zw">3. Do not judge the quality of code solely by its size (page 344).</p>

    <h2 id="nav_point_252" class="calibre24">12.7 Questions</h2>

    <p class="zw">1. Can Program 12.3 be written without using a current variable? If so, compare the
      resulting function to the original.</p>

    <p class="zw"><img alt="" src="../images/00005.jpeg" class="calibre25">2. Some data structures textbooks suggest
      using a "header node" in a singly linked
      list. This dummy node is always the first element in the list and eliminates the
      special case code for inserting at the beginning of the list. Discuss the pros and cons
      of this technique.</p>

    <p class="zw">3. Where would the insertion function in Program 12.3 put a node with a duplicate
      value? What would be the effect of changing the comparison from &lt; to &lt;=?
    </p>

    <p class="zw"><img alt="" src="../images/00005.jpeg" class="calibre25">4. Discuss techniques for omitting the value
      field from the root node of a doubly
      linked list.</p>

    <p class="zw">5. What would be the result if the call to malloc in Program 12.7 were performed at
      the beginning of the function?</p>

    <p class="zw">6. Is it possible to sort the nodes in an unordered, singly linked list?</p>

    <p class="zw"><img alt="" src="../images/00005.jpeg" class="calibre25">7. A concordance list is an alphabetic list
      of the words that appear in a book or article.
      You can implement a concordance list using an ordered, singly linked list of strings
      with an insertion function that does not add duplicate words to the list. The
      problem with this implementation is that the time it takes to search the list
      increases as the list grows in size.</p>

    <p class="zw">Figure 12.1 illustrates an alternative data structure for storing the concordance
      list. The idea is to break the large list into 26 smaller lists—one list of words for
      each letter of the alphabet. Each of the nodes in the primary list contains a letter
      and points to an ordered, singly linked list of words (stored as strings) that begin
      with this letter.</p>

    <p class="zw">How does the time to search this structure for a specific word compare to the
      time to search an ordered, singly linked list containing all of the words?</p>

    <p class="tu"><img alt="" src="../images/00259.jpeg" class="calibre14"></p>

    <p class="tu_ti">Figure 12.1 A concordance list</p>

    <h2 id="nav_point_253" class="calibre24">12.8 Programming Exercises</h2>

    <p class="zw"><img alt="" src="../images/00005.jpeg" class="calibre25">★ 1. Write a function that counts the number,
      of nodes in a singly linked list. It should take a pointer to the first node in the list as its only argument.
      What must you know in order to write this function? What other jobs can this function perform?</p>

    <p class="zw">★ 2. Write a function to locate a particular value in an unordered, singly linked list, and
      return a pointer to that node. You may assume that the node structure is defined in
      the file singly_linked_list_node.h.</p>

    <p class="zw">Are any changes needed in order to make the function work on an ordered,
      singly linked list?</p>

    <p class="zw">★★★ 3. Rewrite Program 12.7, dll_insert, so that the head and tail pointers are passed in
      as separate pointers rather than as part of a root node. What effect does this change
      have on the logic of the function?</p>

    <p class="zw">★★★★ 4. Write a function that reverses the order of the nodes in a singly linked list. The
      function should have the following prototype:</p>
    <pre class="code"><code class="calibre8">　　　struct NODE * sll_reverse( struct NODE *first);</code></pre>

    <p class="zw">Declare the node structure in the file singly_linked_list_node.h.</p>

    <p class="zw">The argument points to the first node in the list. After the list is rearranged, the
      function returns a pointer to the new head of the list. The link field of the last node
      in the list will contain NULL, and in the event of an empty list (first == NULL) the
      function should return NULL.</p>

    <p class="zw"><img alt="" src="../images/00005.jpeg" class="calibre25">★★★ 5. Write a program to remove a node from
      a singly linked list. The function should have the following prototype:</p>
    <pre class="code"><code class="calibre8">　　　int sll_remove( struct NODE **rootp, struct NODE *node );</code></pre>

    <p class="zw">You may assume that the node structure is defined in the file
      singly_Iinked_list_node.h. The first argument points to the root pointer of the
      list, and the second points to the node that is to be removed. The function returns
      false if the list does not contain the indicated node, otherwise it removes the node
      and returns true.</p>
    <p class="zw">Is there any advantage in taking a pointer to the node to remove as opposed to
      taking the value?</p>

    <p class="zw">★★★ 6. Write a program to remove a node from a doubly linked list. The function should
      have the following prototype:</p>
    <pre class="code"><code class="calibre8">　　　int dll_remove( struct NODE *rootp, struct NODE *node );</code></pre>

    <p class="zw">You may assume that the node structure is defined in the file
      doubly_linked_list_node.h. The first argument points to a node containing the
      root pointers for the list (the same as with Program 12.7), and the second points to
      the node that is to be removed. The function returns false if the list does not
      contain the indicated node, otherwise it removes the node and returns true.</p>

    <p class="zw">★★★★★ 7. Write a function to insert a new word into the concordance list described in
      Question 7. The function should take a pointer to the list pointer and a string as
      its arguments. The string is assumed to contain a single word. If the word does not
      already exist in the list, it should be copied into dynamically allocated memory and
      then inserted. The function should return true if the string was inserted; and false if
      the string already existed in the list, did not begin with a letter, or if anything else
      went wrong.</p>

    <p class="zw">The function should maintain the primary list in order by the letter of the node
      and the secondary lists in order by the words.</p>

  </div>
</body>

</html>